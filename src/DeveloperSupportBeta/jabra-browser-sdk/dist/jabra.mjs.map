{"version":3,"file":"jabra.mjs","sources":["../src/jabra.browser.integration-2.1.ts","../node_modules/eventemitter3/index.js","../src/Analytics/AnalyticsEvent.ts","../src/Analytics/AnalyticsEventLog.ts","../src/Analytics/Analytics.ts"],"sourcesContent":["/*\nJabra Browser Integration\nhttps://github.com/gnaudio/jabra-browser-integration\n\nMIT License\n\nCopyright (c) 2017 GN Audio A/S (Jabra)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\n/**\n * Version of this javascript api (should match version number in file apart from possible alfa/beta designator).\n */\nexport const apiVersion = \"2.1.0.beta1\";\n\n/**\n * Is the current version a beta ?\n */\nconst isBeta = apiVersion.includes(\"beta\");\n\n/**\n * Id of proper (production) release of browser plugin.\n */\nconst prodExtensionId = \"okpeabepajdgiepelmhkfhkjlhhmofma\";\n\n/**\n * Id of beta release of browser plugin.\n */\nconst betaExtensionId = \"igcbbdnhomedfadljgcmcfpdcoonihfe\";\n\n/**\n * Contains information about installed components.\n */\nexport interface InstallInfo {\n  installationOk: boolean;\n  version_chromehost: string;\n  version_nativesdk: string;\n  version_browserextension: string;\n  version_jsapi: string;\n  browserextension_id: string;\n  browserextension_type: string;\n}\n\n/**\n * Contains information about a device\n */\nexport interface DeviceInfo {\n  deviceID: number;\n  deviceName: string;\n  deviceConnection: number;\n  deviceFeatures: ReadonlyArray<DeviceFeature>;\n  errStatus: number;\n  isBTPaired?: boolean;\n  isInFirmwareUpdateMode: boolean;\n  productID: number;\n  serialNumber?: string;\n  variant: string;\n  dongleName?: string;\n  skypeCertified: boolean;\n  firmwareVersion?: string;\n  electricSerialNumbers?: ReadonlyArray<string>;\n  batteryLevelInPercent?: number;\n  batteryCharging?: boolean;\n  batteryLow?: boolean;\n  leftEarBudStatus?: boolean;\n  equalizerEnabled?: boolean;\n  busyLight?: boolean;\n\n  /**\n   * Set to ID of related dongle and/or headset if both are paired and connected.\n   */\n  connectedDeviceID?: number;\n\n  /**\n   * Set if the same device is connected in more than one way (BT and USB), so\n   * the device appears twice.\n   */\n  aliasDeviceID?: number;\n\n  /**\n   * Only available in debug versions.\n   */\n  parentInstanceId?: string;\n\n  /**\n   * Only available in debug versions.\n   */\n  usbDevicePath?: string;\n\n  /**\n   * Browser media device information group (browser session specific).\n   * Only available when calling getDevices/getActiveDevice with includeBrowserMediaDeviceInfo argument set to true.\n   */\n  browserGroupId?: string;\n\n  /**\n   * The browser's unique identifier for the input (e.g. microphone) part of the Jabra device (page origin specific).\n   * Only available when calling getDevices/getActiveDevice with includeBrowserMediaDeviceInfo argument set to true.\n   */\n  browserAudioInputId?: string;\n\n  /**\n   * The browser's unique identifier for an output (e.g. speaker) part of the Jabra device (page origin specific).\n   * Only available when calling getDevices/getActiveDevice with includeBrowserMediaDeviceInfo argument set to true.\n   */\n  browserAudioOutputId?: string;\n\n  /**\n   * The browser's textual descriptor of the device.\n   * Only available when calling getDevices/getActiveDevice with includeBrowserMediaDeviceInfo argument set to true.\n   */\n  browserLabel?: string;\n}\n\n/**\n * A combination of a media stream and information of the associated device from the view of the browser.\n */\nexport interface MediaStreamAndDeviceInfoPair {\n  stream: MediaStream;\n  deviceInfo: DeviceInfo;\n}\n\n/**\n * Names of command response events.\n */\nconst commandEventsList = [\n  \"devices\",\n  \"activedevice\",\n  \"getinstallinfo\",\n  \"Version\",\n  \"setmmifocus\",\n  \"setactivedevice2\",\n  \"setbusylight\",\n  \"setremotemmilightaction\"\n];\n\n/**\n * All button event names.\n */\nexport type ButtonEventName =\n  | \"mute\"\n  | \"unmute\"\n  | \"acceptcall\"\n  | \"endcall\"\n  | \"reject\"\n  | \"flash\"\n  | \"online\"\n  | \"offline\"\n  | \"linebusy\"\n  | \"lineidle\"\n  | \"redial\"\n  | \"key0\"\n  | \"key1\"\n  | \"key2\"\n  | \"key3\"\n  | \"key4\"\n  | \"key5\"\n  | \"key6\"\n  | \"key7\"\n  | \"key8\"\n  | \"key9\"\n  | \"keyStar\"\n  | \"keyPound\"\n  | \"keyClear\"\n  | \"Online\"\n  | \"speedDial\"\n  | \"voiceMail\"\n  | \"LineBusy\"\n  | \"outOfRange\"\n  | \"intoRange\"\n  | \"pseudoAcceptcall\"\n  | \"pseudoEndcall\"\n  | \"button1\"\n  | \"button2\"\n  | \"button3\"\n  | \"volumeUp\"\n  | \"volumeDown\"\n  | \"fireAlarm\"\n  | \"jackConnection\"\n  | \"jackDisConnection\"\n  | \"qdConnection\"\n  | \"qdDisconnection\"\n  | \"headsetConnection\"\n  | \"headsetDisConnection\";\n\n/**\n * Names of events describing device being added/removed.\n */\nexport type AttachedDeattachedEventName = \"device attached\" | \"device detached\";\n\n/**\n * Names of events presently without a type definition (subject to change).\n */\nexport type UntypedEventName =\n  | \"busylight\"\n  | \"hearThrough\"\n  | \"batteryStatus\"\n  | \"gnpButton\"\n  | \"mmi\"\n  | \"error\";\n\n/**\n * All possible device events as discriminative  union.\n */\nexport type EventName =\n  | ButtonEventName\n  | AttachedDeattachedEventName\n  | \"devlog\"\n  | UntypedEventName;\n\n/**\n * All possible device events as internal array.\n */\nlet eventNamesList: ReadonlyArray<EventName> = [\n  \"mute\",\n  \"unmute\",\n  \"device attached\",\n  \"device detached\",\n  \"acceptcall\",\n  \"endcall\",\n  \"reject\",\n  \"flash\",\n  \"online\",\n  \"offline\",\n  \"linebusy\",\n  \"lineidle\",\n  \"redial\",\n  \"key0\",\n  \"key1\",\n  \"key2\",\n  \"key3\",\n  \"key4\",\n  \"key5\",\n  \"key6\",\n  \"key7\",\n  \"key8\",\n  \"key9\",\n  \"keyStar\",\n  \"keyPound\",\n  \"keyClear\",\n  \"Online\",\n  \"speedDial\",\n  \"voiceMail\",\n  \"LineBusy\",\n  \"outOfRange\",\n  \"intoRange\",\n  \"pseudoAcceptcall\",\n  \"pseudoEndcall\",\n  \"button1\",\n  \"button2\",\n  \"button3\",\n  \"volumeUp\",\n  \"volumeDown\",\n  \"fireAlarm\",\n  \"jackConnection\",\n  \"jackDisConnection\",\n  \"qdConnection\",\n  \"qdDisconnection\",\n  \"headsetConnection\",\n  \"headsetDisConnection\",\n  \"devlog\",\n  \"busylight\",\n  \"hearThrough\",\n  \"batteryStatus\",\n  \"gnpButton\",\n  \"mmi\",\n  \"error\"\n];\n\n/**\n * Error status codes returned by SDK. Same as Jabra_ErrorStatus in native SDK.\n */\nexport enum ErrorCodes {\n  NoError = 0,\n  SSLError = 1,\n  CertError = 2,\n  NetworkError = 3,\n  DownloadError = 4,\n  ParseError = 5,\n  OtherError = 6,\n  DeviceInfoError = 7,\n  FileNotAccessible = 8,\n  FileNotCompatible = 9,\n  Device_NotFound = 10,\n  Parameter_fail = 11,\n  Authorization_failed = 12,\n  FileNotAvailable = 13,\n  ConfigParseError = 14,\n  SetSettings_Fail = 15,\n  Device_Reboot = 16,\n  Device_ReadFail = 17,\n  Device_NotReady = 18,\n  FilePartiallyCompatible = 19\n}\n\n/**\n * Error return codes. Same as Jabra_ReturnCode in native SDK.\n */\nexport enum ErrorReturnCodes {\n  Return_Ok = 0,\n  Device_Unknown = 1,\n  Device_Invalid = 2,\n  Not_Supported = 3,\n  Return_ParameterFail = 4,\n  ProtectedSetting_Write = 5,\n  No_Information = 6,\n  NetworkRequest_Fail = 7,\n  Device_WriteFail = 8,\n  Device_ReadFails = 9,\n  No_FactorySupported = 10,\n  System_Error = 11,\n  Device_BadState = 12,\n  FileWrite_Fail = 13,\n  File_AlreadyExists = 14,\n  File_Not_Accessible = 15,\n  Firmware_UpToDate = 16,\n  Firmware_Available = 17,\n  Return_Async = 18,\n  Invalid_Authorization = 19,\n  FWU_Application_Not_Available = 20,\n  Device_AlreadyConnected = 21,\n  Device_NotConnected = 22,\n  CannotClear_DeviceConnected = 23,\n  Device_Rebooted = 24,\n  Upload_AlreadyInProgress = 25,\n  Download_AlreadyInProgress = 26\n}\n\n/**\n * Custom error returned by commands expecting results when failing.\n */\nexport class CommandError extends Error {\n  command: string;\n  errmessage: string;\n  data: any;\n\n  constructor(command: string, errmessage: string, data?: string) {\n    super(\n      \"Command \" +\n        command +\n        \" failed with error  message \" +\n        errmessage +\n        \" and details: \" +\n        JSON.stringify(data || {})\n    );\n    this.command = command;\n    this.errmessage = errmessage;\n    this.data = data;\n    this.name = \"CommandError\";\n  }\n}\n\n/**\n * Internal helper that stores information about the promise to resolve/reject\n * for a command being processed.\n */\ninterface PromiseCallbacks {\n  cmd: string;\n  resolve: (value?: any | PromiseLike<any> | undefined) => void;\n  reject: (err: Error) => void;\n}\n\n/**\n * General event type for call backs.\n */\nexport interface Event {\n  message: EventName;\n  data: { [key: string]: any } & {\n    deviceID: number;\n    activeDevice?: boolean;\n    // ...\n  };\n}\n\n/**\n * Event type for device added/removed.\n */\nexport interface DeviceAttachedDeAttachedEvent {\n  message: \"device attached\" | \"device detached\";\n  data: DeviceInfo;\n}\n\n/**\n * Event type for button events;\n */\nexport interface ButtonEvent {\n  message: ButtonEventName;\n  data: {\n    deviceID: number;\n    activeDevice: boolean;\n    buttonInData: boolean;\n    isOffHook: boolean;\n    ringing: boolean;\n    translatedInData: number;\n  };\n}\n\n/**\n * Event type for dev log call backs.\n */\nexport interface DevLogEvent {\n  message: \"devlog\";\n  data: {\n    deviceID: number;\n    activeDevice: boolean;\n    AppID: string;\n    ESN: string;\n    FW: string;\n    LocalTimeStamp: string;\n    Pid: number;\n    TimeStampMs: number;\n    Variant: string;\n    \"Device Name\": string;\n    \"Raw data\": string;\n    \"Seq.No\": number;\n    \"TX Acoustic Logging Level\": string;\n    \"TX Acoustic Logging Peak\": string;\n    \"RX Acoustic Logging Level\": string;\n    \"RX Acoustic Logging Peak\": string;\n    Speech_Analysis_TX: string;\n    Speech_Analysis_RX: string;\n    \"Boom Position Guidance OK\": string;\n    \"Bad_Mic_detect Flag\": string;\n    ID: string;\n  };\n}\n\n/**\n * The format of errors returned.\n */\nexport type ClientError =\n  | any\n  | {\n      error: string;\n    };\n\n/**\n * The format of messages returned.\n */\nexport type ClientMessage =\n  | any\n  | {\n      message: string;\n    };\n\n/**\n * Type for event callback functions..\n */\nexport declare type EventCallback = (\n  event: Event | DeviceAttachedDeAttachedEvent | ButtonEvent | DevLogEvent\n) => void;\n\n/**\n * Internal mapping from all known events to array of registered callbacks. All possible events are setup\n * initially. Callbacks values are configured at runtime.\n */\nconst eventListeners: Map<EventName, Array<EventCallback>> = new Map<\n  EventName,\n  Array<EventCallback>\n>();\neventNamesList.forEach((event: EventName) => eventListeners.set(event, []));\n\n/**\n * Device feature codes.\n */\nexport enum DeviceFeature {\n  BusyLight = 1000,\n  FactoryReset = 1001,\n  PairingList = 1002,\n  RemoteMMI = 1003,\n  MusicEqualizer = 1004,\n  EarbudInterconnectionStatus = 1005,\n  StepRate = 1006,\n  HeartRate = 1007,\n  RRInterval = 1008,\n  RingtoneUpload = 1009,\n  ImageUpload = 1010,\n  NeedsExplicitRebootAfterOta = 1011,\n  NeedsToBePutIncCradleToCompleteFwu = 1012,\n  RemoteMMIv2 = 1013,\n  Logging = 1014,\n  PreferredSoftphoneListInDevice = 1015,\n  VoiceAssistant = 1016,\n  PlayRingtone = 1017\n}\n\n/**\n * A specification of a button for MMI capturing.\n */\nexport enum RemoteMmiType {\n  MMI_TYPE_MFB = 0,\n  MMI_TYPE_VOLUP = 1,\n  MMI_TYPE_VOLDOWN = 2,\n  MMI_TYPE_VCB = 3,\n  MMI_TYPE_APP = 4,\n  MMI_TYPE_TR_FORW = 5,\n  MMI_TYPE_TR_BACK = 6,\n  MMI_TYPE_PLAY = 7,\n  MMI_TYPE_MUTE = 8,\n  MMI_TYPE_HOOK_OFF = 9,\n  MMI_TYPE_HOOK_ON = 10,\n  MMI_TYPE_BLUETOOTH = 11,\n  MMI_TYPE_JABRA = 12,\n  MMI_TYPE_BATTERY = 13,\n  MMI_TYPE_PROG = 14,\n  MMI_TYPE_LINK = 15,\n  MMI_TYPE_ANC = 16,\n  MMI_TYPE_LISTEN_IN = 17,\n  MMI_TYPE_DOT3 = 18,\n  MMI_TYPE_DOT4 = 19,\n  MMI_TYPE_ALL = 255\n}\n\n/**\n * A MMI effect specification for light on, off or blinking in different tempo.\n */\nexport enum RemoteMmiSequence {\n  MMI_LED_SEQUENCE_OFF = 0,\n  MMI_LED_SEQUENCE_ON = 1,\n  MMI_LED_SEQUENCE_SLOW = 2,\n  MMI_LED_SEQUENCE_FAST = 3\n}\n\n/**\n * MMI button actions reported when button has focus.\n */\nexport enum RemoteMmiActionInput {\n  MMI_ACTION_UP = 1,\n  MMI_ACTION_DOWN = 2,\n  MMI_ACTION_TAP = 4,\n  MMI_ACTION_DOUBLE_TAP = 8,\n  MMI_ACTION_PRESS = 16,\n  MMI_ACTION_LONG_PRESS = 32,\n  MMI_ACTION_X_LONG_PRESS = 64\n}\n\n/**\n * A 3 x 8 bit set of RGB colors. Numbers can be between 0-255.\n */\nexport type ColorType = [number, number, number];\n\n/**\n * The log level currently used internally in this api facade. Initially this is set to show errors and\n * warnings until a logEvent (>=0.5) changes this when initializing the extension or when the user\n * changes the log level. Available in the API for testing only - do not use this in normal applications.\n */\nexport let logLevel: number = 2;\n\n/**\n * An internal logger helper.\n */\nconst logger = new (class {\n  trace(msg: string) {\n    if (logLevel >= 4) {\n      console.log(msg);\n    }\n  }\n\n  info(msg: string) {\n    if (logLevel >= 3) {\n      console.log(msg);\n    }\n  }\n\n  warn(msg: string) {\n    if (logLevel >= 2) {\n      console.warn(msg);\n    }\n  }\n\n  error(msg: string) {\n    if (logLevel >= 1) {\n      console.error(msg);\n    }\n  }\n})();\n\n/**\n * A reasonably unique ID for our browser extension client that makes it possible to\n * differentiate between different instances of this api in different browser tabs.\n */\nconst apiClientId: string = Math.random()\n  .toString(36)\n  .substr(2, 9);\n\n/**\n * A mapping from unique request ids for commands and the promise information needed\n * to resolve/reject them by an incomming event.\n */\nconst sendRequestResultMap: Map<string, PromiseCallbacks> = new Map<\n  string,\n  PromiseCallbacks\n>();\n\n/**\n * A counter used to generate unique request ID's used to match commands and returning events.\n */\nlet requestNumber: number = 1;\n\n/**\n * Contains initialization information used by the init/shutdown methods.\n */\nlet initState: {\n  initialized?: boolean;\n  initializing?: boolean;\n  eventCallback?: (event: any) => void;\n} = {};\n\n/**\n * The JavaScript library must be initialized using this function. It returns a promise that\n * resolves when initialization is complete.\n */\nexport function init(): Promise<void> {\n  return new Promise((resolve, reject) => {\n    // Only Chrome is currently supported\n    let isChrome =\n      /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);\n    if (!isChrome) {\n      return reject(\n        new Error(\n          \"Jabra Browser Integration: Only supported by <a href='https://google.com/chrome'>Google Chrome</a>.\"\n        )\n      );\n    }\n\n    if (initState.initialized || initState.initializing) {\n      return reject(new Error(\"Jabra Browser Integration already initialized\"));\n    }\n\n    initState.initializing = true;\n    sendRequestResultMap.clear();\n    let duringInit = true;\n\n    initState.eventCallback = (event: any) => {\n      if (\n        event.source === window &&\n        event.data.direction &&\n        event.data.direction === \"jabra-headset-extension-from-content-script\"\n      ) {\n        let eventApiClientId = event.data.apiClientId || \"\";\n        let requestId = event.data.requestId || \"\";\n\n        // Only accept responses from our own requests or from device.\n        if (apiClientId === eventApiClientId || eventApiClientId === \"\") {\n          logger.trace(\n            \"Receiving event from content script: \" + JSON.stringify(event.data)\n          );\n\n          // For backwards compatibility a blank message might be send as \"na\".\n          if (event.data.message === \"na\") {\n            delete event.data.message;\n          }\n\n          // For backward compatability reinterprent messages starting with error as errors:\n          if (event.data.message && event.data.message.startsWith(\"Error:\")) {\n            event.data.error = event.data.message;\n            delete event.data.message;\n          }\n\n          if (event.data.message) {\n            logger.trace(\"Got message: \" + JSON.stringify(event.data));\n            const normalizedMsg: string = event.data.message.substring(7); // Strip \"Event\" prefix;\n\n            if (normalizedMsg.startsWith(\"logLevel\")) {\n              logLevel = parseInt(event.data.message.substring(16));\n              logger.trace(\"Logger set to level \" + logLevel);\n\n              // Loglevels are internal events and not an indication of proper\n              // initialization so skip rest of handling for log levels.\n              return;\n            }\n\n            const commandIndex = commandEventsList.findIndex(e =>\n              normalizedMsg.startsWith(e)\n            );\n            if (commandIndex >= 0) {\n              // For install info and version command, we need to add api version number.\n              if (\n                normalizedMsg === \"getinstallinfo\" ||\n                normalizedMsg.startsWith(\"Version \")\n              ) {\n                // Old extension/host won't have data so make sure it exists to avoid breakage.\n                if (!event.data.data) {\n                  event.data.data = {};\n                }\n                event.data.data.version_jsapi = apiVersion;\n              }\n\n              // For install info also check if the full installation is consistent.\n              if (normalizedMsg === \"getinstallinfo\") {\n                event.data.data.installationOk = isInstallationOk(\n                  event.data.data\n                );\n              }\n\n              // Lookup and check that we have identified a (real) command target to pair result with.\n              let resultTarget = identifyAndCleanupResultTarget(requestId);\n              if (resultTarget) {\n                let result: any;\n                if (event.data.data) {\n                  result = event.data.data;\n                } else {\n                  let dataPosition = commandEventsList[commandIndex].length + 1;\n                  let dataStr = normalizedMsg.substring(dataPosition);\n                  result = {};\n                  if (dataStr) {\n                    result.legacy_result = dataStr;\n                  }\n                }\n\n                resultTarget.resolve(result);\n              } else {\n                let err =\n                  \"Result target information missing for message \" +\n                  event.data.message +\n                  \". This is likely due to some software components that have not been updated or a software bug. Please upgrade extension and/or chromehost\";\n                logger.error(err);\n                notify(\"error\", {\n                  error: err,\n                  message: event.data.message\n                });\n              }\n            } else if (eventListeners.has(normalizedMsg as EventName)) {\n              let clientEvent: ClientMessage = JSON.parse(\n                JSON.stringify(event.data)\n              );\n              delete clientEvent.direction;\n              delete clientEvent.apiClientId;\n              delete clientEvent.requestId;\n              clientEvent.message = normalizedMsg;\n\n              notify(normalizedMsg as EventName, clientEvent);\n            } else {\n              logger.warn(\"Unknown message: \" + event.data.message);\n              notify(\"error\", {\n                error: \"Unknown message: \",\n                message: event.data.message\n              });\n              // Don't let unknown messages complete initialization so stop here.\n              return;\n            }\n\n            if (duringInit) {\n              duringInit = false;\n              return resolve();\n            }\n          } else if (event.data.error) {\n            logger.error(\"Got error: \" + event.data.error);\n            const normalizedError: string = event.data.error.substring(7); // Strip \"Error\" prefix;\n\n            // Reject target promise if there is one - otherwise send a general error.\n            let resultTarget = identifyAndCleanupResultTarget(requestId);\n            if (resultTarget) {\n              resultTarget.reject(\n                new CommandError(\n                  resultTarget.cmd,\n                  normalizedError,\n                  event.data.data\n                )\n              );\n            } else {\n              let clientError: ClientError = JSON.parse(\n                JSON.stringify(event.data)\n              );\n              delete clientError.direction;\n              delete clientError.apiClientId;\n              delete clientError.requestId;\n              clientError.error = normalizedError;\n\n              notify(\"error\", clientError);\n            }\n\n            if (duringInit) {\n              duringInit = false;\n              return reject(new Error(event.data.error));\n            }\n          }\n        }\n      }\n    };\n\n    window.addEventListener(\"message\", initState.eventCallback!);\n\n    // Initial getversion and loglevel.\n    setTimeout(() => {\n      sendCmdWithResult(\"getversion\", null, false)\n        .then(result => {\n          let resultStr =\n            typeof result === \"string\" || result instanceof String\n              ? result\n              : JSON.stringify(result, null, 2);\n          logger.trace(\"getversion returned successfully with : \" + resultStr);\n\n          sendCmd(\"logLevel\", null, false);\n        })\n        .catch(error => {\n          logger.error(error);\n        });\n    }, 1000);\n\n    // Check if the web-extension is installed\n    setTimeout(function() {\n      if (duringInit === true) {\n        duringInit = false;\n        const extensionId = isBeta ? betaExtensionId : prodExtensionId;\n        reject(\n          new Error(\n            \"Jabra Browser Integration: You need to use this <a href='https://chrome.google.com/webstore/detail/\" +\n              extensionId +\n              \"'>Extension</a> and then reload this page\"\n          )\n        );\n      }\n    }, 5000);\n\n    /**\n     * Helper that checks if the installation is consistent.\n     */\n    function isInstallationOk(installInfo: InstallInfo): boolean {\n      let browserSdkVersions = [\n        installInfo.version_browserextension,\n        installInfo.version_chromehost,\n        installInfo.version_jsapi\n      ];\n\n      // Check that we have install information for all components.\n      if (browserSdkVersions.some(v => !v) || !installInfo.version_nativesdk) {\n        return false;\n      }\n\n      // Check that different beta versions are not mixed.\n      if (\n        !browserSdkVersions\n          .map(v => {\n            let betaIndex = v.lastIndexOf(\"beta\");\n            if (betaIndex >= 0 && v.length > betaIndex + 4) {\n              return v.substr(betaIndex + 4);\n            } else {\n              return undefined;\n            }\n          })\n          .filter(v => v)\n          // @ts-ignore\n          .every((v, i, arr) => v === arr[0])\n      ) {\n        return false;\n      }\n\n      return true;\n    }\n\n    /**\n     * Post event/error to subscribers.\n     */\n    function notify(\n      eventName: EventName,\n      eventMsg: ClientMessage | ClientError\n    ): void {\n      let callbacks = eventListeners.get(eventName);\n      if (callbacks) {\n        callbacks.forEach(callback => {\n          callback(eventMsg);\n        });\n      } else {\n        // This should not occur unless internal event mappings in this file\n        // are not configured correctly.\n        logger.error(\"Unexpected unknown eventName: \" + eventName);\n      }\n    }\n\n    /** Lookup any previous stored result target information for the request.\n     *   Does cleanup if target found (so it can't be called twice for a request).\n     *   Nb. requestId's are only provided by >= 0.5 extension and chromehost.\n     */\n    function identifyAndCleanupResultTarget(\n      requestId?: string\n    ): PromiseCallbacks | undefined {\n      // Lookup any previous stored result target information for the request.\n      // Nb. requestId's are only provided by >= 0.5 extension and chromehost.\n      let resultTarget: PromiseCallbacks | undefined;\n      if (requestId) {\n        resultTarget = sendRequestResultMap.get(requestId);\n        // Remember to cleanup to avoid memory leak!\n        sendRequestResultMap.delete(requestId);\n      } else if (sendRequestResultMap.size === 1) {\n        // We don't have a requestId but since only one is being executed we\n        // can assume this is the one.\n        let value = sendRequestResultMap.entries().next().value;\n        resultTarget = value[1];\n        // Remember to cleanup to avoid memory leak and for future\n        // requests like this to be resolved.\n        sendRequestResultMap.delete(value[0]);\n      } else {\n        // No idea what target matches what request - give up.\n        resultTarget = undefined;\n      }\n\n      // Warn in case of likely memory leak:\n      const mapSize = sendRequestResultMap.size;\n      if (mapSize > 10 && mapSize % 10 === 0) {\n        // Limit warnings to every 10 size increases to avoid flooding:\n        logger.warn(\n          \"Memory leak found - Request result map is getting too large (size #\" +\n            mapSize +\n            \")\"\n        );\n      }\n\n      return resultTarget;\n    }\n\n    initState.initialized = true;\n    initState.initializing = false;\n  });\n}\n\n/**\n * De-initialize the api after use. Not normally used as api will normally\n * stay in use thoughout an application - mostly of interest for testing.\n */\nexport function shutdown(): Promise<void> {\n  if (initState.initialized) {\n    window.removeEventListener(\"message\", initState.eventCallback!);\n    initState.eventCallback = undefined;\n    sendRequestResultMap.clear();\n    requestNumber = 1;\n    initState.initialized = false;\n\n    // Unsubscribe all.\n    // @ts-ignore\n    eventListeners.forEach((value, key) => {\n      value = [];\n    });\n    return Promise.resolve();\n  }\n\n  return Promise.reject(new Error(\"Browser integration not initialized\"));\n}\n\n/**\n * Internal helper that returns an array of valid event keys that correspond to the event specificator\n * and are known to exist in our event listener map.\n */\nfunction getEvents(\n  nameSpec: string | RegExp | Array<string | RegExp>\n): ReadonlyArray<string> {\n  if (Array.isArray(nameSpec)) {\n    // @ts-ignore: Disable wrong \"argument not assignable\" error in ts 3.4\n    return [\n      // @ts-ignore\n      ...new Set<string>([].concat.apply([], nameSpec.map(a => getEvents(a))))\n    ];\n  } else if (nameSpec instanceof RegExp) {\n    return Array.from<string>(eventListeners.keys()).filter(key =>\n      nameSpec.test(key)\n    );\n  } else {\n    // String\n    if (eventListeners.has(nameSpec as EventName)) {\n      return [nameSpec];\n    } else {\n      logger.warn(\n        \"Unknown event \" +\n          nameSpec +\n          \" ignored when adding/removing eventlistener\"\n      );\n    }\n  }\n\n  return [];\n}\n\n/**\n * Hook up listener call back to specified event(s) as specified by initial name specification argument nameSpec.\n * When the nameSpec argument is a string, this correspond to a single named event. When the argument is a regular\n * expression all lister subscribes to all matching events. If the argument is an array it recursively subscribes\n * to all events specified in the array.\n */\nexport function addEventListener(\n  nameSpec: AttachedDeattachedEventName,\n  callback: (event: DeviceInfo) => void\n): void;\nexport function addEventListener(\n  nameSpec: \"devlog\",\n  callback: (event: DevLogEvent) => void\n): void;\nexport function addEventListener(\n  nameSpec: ButtonEventName,\n  callback: (event: ButtonEvent) => void\n): void;\nexport function addEventListener(\n  nameSpec: UntypedEventName,\n  callback: (event: Event) => void\n): void;\nexport function addEventListener(\n  nameSpec: EventName | RegExp | Array<EventName | RegExp>,\n  callback: EventCallback\n): void;\nexport function addEventListener(\n  nameSpec: any,\n  callback: (event: any) => void\n): void {\n  getEvents(nameSpec).map(name => {\n    let callbacks = eventListeners.get(name as EventName);\n    if (!callbacks!.find(c => c === callback)) {\n      callbacks!.push(callback);\n    }\n  });\n}\n\n/**\n * Remove existing listener to specified event(s). The callback must correspond to the exact callback provided\n * to a previous addEventListener.\n */\nexport function removeEventListener(\n  nameSpec: AttachedDeattachedEventName,\n  callback: (event: DeviceInfo) => void\n): void;\nexport function removeEventListener(\n  nameSpec: \"devlog\",\n  callback: (event: DevLogEvent) => void\n): void;\nexport function removeEventListener(\n  nameSpec: ButtonEventName,\n  callback: (event: ButtonEvent) => void\n): void;\nexport function removeEventListener(\n  nameSpec: UntypedEventName,\n  callback: (event: Event) => void\n): void;\nexport function removeEventListener(\n  nameSpec: EventName | RegExp | Array<EventName | RegExp>,\n  callback: EventCallback\n): void;\nexport function removeEventListener(\n  nameSpec: any,\n  callback: (event: any) => void\n): void {\n  getEvents(nameSpec).map(name => {\n    let callbacks = eventListeners.get(name as EventName);\n    let findIndex = callbacks!.findIndex(c => c === callback);\n    if (findIndex >= 0) {\n      callbacks!.splice(findIndex, 1);\n    }\n  });\n}\n\n/**\n * Activate ringer (if supported) on the Jabra Device\n */\nexport function ring(): void {\n  sendCmd(\"ring\");\n}\n\n/**\n * Change state to in-a-call.\n */\nexport function offHook(): void {\n  sendCmd(\"offhook\");\n}\n\n/**\n * Change state to idle (not-in-a-call).\n */\nexport function onHook(): void {\n  sendCmd(\"onhook\");\n}\n\n/**\n * Mutes the microphone (if supported).\n */\nexport function mute(): void {\n  sendCmd(\"mute\");\n}\n\n/**\n * Unmutes the microphone (if supported).\n */\nexport function unmute(): void {\n  sendCmd(\"unmute\");\n}\n\n/**\n * Change state to held (if supported).\n */\nexport function hold(): void {\n  sendCmd(\"hold\");\n}\n\n/**\n * Change state from held to OffHook (if supported).\n */\nexport function resume(): void {\n  sendCmd(\"resume\");\n}\n\n/**\n * Capture/release buttons for customization (if supported). This turns off default behavior and enables mmi events to\n * be received instead. It also allows for mmi actions to be applied like changing lights with setRemoteMmiLightAction.\n *\n * @param type The button that should be captured/released.\n * @param capture True if button should be captured, false if it should be released.\n *\n * @returns A promise that is resolved once operation completes.\n */\nexport function setMmiFocus(\n  type: RemoteMmiType | string,\n  capture: boolean | string\n): Promise<void> {\n  let typeVal = numberOrString(type);\n  let captureVal = booleanOrString(capture);\n  return sendCmdWithResult<void>(\"setmmifocus\", {\n    type: typeVal,\n    capture: captureVal\n  });\n}\n\n/**\n * Change light/color on a previously captured button.\n * Nb. This requires the button to be previously captured though setMMiFocus.\n *\n * @param type The button that should be captured/released.\n * @param color An RGB array of 3x integers or a RGB number (with 0x or # prefix for hex).\n * @param effect What effect to apply to the button.\n *\n * @returns A promise that is resolved once operation completes.\n */\nexport function setRemoteMmiLightAction(\n  type: RemoteMmiType | string,\n  color: ColorType | string | number,\n  effect: RemoteMmiSequence | string\n): Promise<void> {\n  let typeVal = numberOrString(type);\n  let colorVal = colorOrString(color);\n  let effectVal = numberOrString(effect);\n  return sendCmdWithResult<void>(\"setremotemmilightaction\", {\n    type: typeVal,\n    color: colorVal,\n    effect: effectVal\n  });\n}\n\n/**\n * Internal helper to get detailed information about the current active Jabra Device\n * from SDK, including current status but excluding media device information.\n */\nfunction _doGetActiveSDKDevice(): Promise<DeviceInfo> {\n  return sendCmdWithResult<DeviceInfo>(\"getactivedevice\");\n}\n\n/**\n * Internal helper to get detailed information about the all attached Jabra Devices\n * from SDK, including current status but excluding media device information.\n */\nfunction _doGetSDKDevices(): Promise<ReadonlyArray<DeviceInfo>> {\n  return sendCmdWithResult<ReadonlyArray<DeviceInfo>>(\"getdevices\");\n}\n\n/**\n * Get detailed information about the current active Jabra Device, including current status\n * and optionally also including related browser media device information.\n *\n * Note that browser media device information requires mediaDevices.getUserMedia or\n * getUserDeviceMediaExt to have been called so permissions are granted. Browser media information\n * is useful for setting a device constraint on mediaDevices.getUserMedia for input or for calling\n * setSinkId (when supported by the browser) to set output.\n */\nexport function getActiveDevice(\n  includeBrowserMediaDeviceInfo: boolean | string = false\n): Promise<DeviceInfo> {\n  let includeBrowserMediaDeviceInfoVal = booleanOrString(\n    includeBrowserMediaDeviceInfo\n  );\n  if (includeBrowserMediaDeviceInfoVal) {\n    return _doGetActiveSDKDevice_And_BrowserDevice();\n  } else {\n    return _doGetActiveSDKDevice();\n  }\n}\n\n/**\n * List detailed information about all attached Jabra Devices, including current status.\n * and optionally also including related browser media device information.\n *\n * Note that browser media device information requires mediaDevices.getUserMedia or\n * getUserDeviceMediaExt to have been called so permissions are granted. Browser media information\n * is useful for setting a device constraint on mediaDevices.getUserMedia for input or for calling\n * setSinkId (when supported by the browser) to set output.\n */\nexport function getDevices(\n  includeBrowserMediaDeviceInfo: boolean | string = false\n): Promise<ReadonlyArray<DeviceInfo>> {\n  let includeBrowserMediaDeviceInfoVal = booleanOrString(\n    includeBrowserMediaDeviceInfo\n  );\n  if (includeBrowserMediaDeviceInfoVal) {\n    return _doGetSDKDevices_And_BrowserDevice();\n  } else {\n    return _doGetSDKDevices();\n  }\n}\n\n/**\n * Internal utility that select a new active device in a backwards compatible way that works with earlier chrome host.\n * Used internally by test tool - do not use otherwise.\n *\n * Note: The active device is a global setting that affects all browser\n * instances using the browser SDK. Unless changed specifically, the setting\n * persist until browser is restarted or device is unplugged.\n *\n * @deprecated Use setActiveDeviceId instead.\n */\nexport function _setActiveDeviceId(id: number | string): void {\n  let idVal = numberOrString(id);\n\n  // Use both new and old way of passing parameters for compatibility with <= v0.5.\n  sendCmd(\"setactivedevice \" + id.toString(), { id: idVal });\n}\n\n/**\n * Select a new active device returning once selection is completed.\n *\n * Note: The active device is a global setting that affects all browser\n * instances using the browser SDK. Unless changed specifically, the setting\n * persist until browser is restarted or device is unplugged.\n *\n * @param id The id number of the new active device.\n * @returns A promise that is resolved once selection completes.\n *\n */\nexport function setActiveDeviceId(id: number | string): Promise<void> {\n  let idVal = numberOrString(id);\n\n  return sendCmdWithResult<void>(\"setactivedevice2\", { id: idVal });\n}\n\n/**\n * Set busylight on active device (if supported)\n *\n * @param busy True if busy light should be set, false if it should be cleared.\n */\nexport function setBusyLight(busy: boolean | string): Promise<void> {\n  let busyVal = booleanOrString(busy);\n\n  return sendCmdWithResult<void>(\"setbusylight\", { busy: busyVal });\n}\n\n/**\n * Get version number information for all components.\n */\nexport function getInstallInfo(): Promise<InstallInfo> {\n  return sendCmdWithResult<InstallInfo>(\"getinstallinfo\");\n}\n\n/**\n * Internal helper that forwards a command to the browser extension\n * without expecting a response.\n */\nfunction sendCmd(\n  cmd: string,\n  args: object | null = null,\n  requireInitializedCheck: boolean = true\n): void {\n  if (\n    !requireInitializedCheck ||\n    (requireInitializedCheck && initState.initialized)\n  ) {\n    let requestId = (requestNumber++).toString();\n\n    let msg = {\n      direction: \"jabra-headset-extension-from-page-script\",\n      message: cmd,\n      args: args || {},\n      requestId: requestId,\n      apiClientId: apiClientId,\n      version_jsapi: apiVersion\n    };\n\n    logger.trace(\"Sending command to content script: \" + JSON.stringify(msg));\n\n    window.postMessage(msg, \"*\");\n  } else {\n    throw new Error(\"Browser integration not initialized\");\n  }\n}\n\n/**\n * Internal helper that forwards a command to the browser extension\n * expecting a response (a promise).\n */\nfunction sendCmdWithResult<T>(\n  cmd: string,\n  args: object | null = null,\n  requireInitializedCheck: boolean = true\n): Promise<T> {\n  if (\n    !requireInitializedCheck ||\n    (requireInitializedCheck && initState.initialized)\n  ) {\n    let requestId = (requestNumber++).toString();\n\n    return new Promise<T>((resolve, reject) => {\n      sendRequestResultMap.set(requestId, { cmd, resolve, reject });\n\n      let msg = {\n        direction: \"jabra-headset-extension-from-page-script\",\n        message: cmd,\n        args: args || {},\n        requestId: requestId,\n        apiClientId: apiClientId,\n        version_jsapi: apiVersion\n      };\n\n      logger.trace(\n        \"Sending command to content script expecting result: \" +\n          JSON.stringify(msg)\n      );\n\n      window.postMessage(msg, \"*\");\n    });\n  } else {\n    return Promise.reject(new Error(\"Browser integration not initialized\"));\n  }\n}\n\n/**\n * Configure an audio html element on a webpage to use jabra audio device as speaker output. Returns a promise with boolean success status.\n * The deviceInfo argument must come from getDeviceInfo or getUserDeviceMediaExt calls.\n */\nexport function trySetDeviceOutput(\n  audioElement: HTMLMediaElement,\n  deviceInfo: DeviceInfo\n): Promise<boolean> {\n  if (!audioElement || !deviceInfo) {\n    return Promise.reject(\n      new Error(\"Call to trySetDeviceOutput has argument(s) missing\")\n    );\n  }\n\n  if (!(typeof (audioElement as any).setSinkId === \"function\")) {\n    return Promise.reject(\n      new Error(\n        \"Your browser does not support required Audio Output Devices API\"\n      )\n    );\n  }\n\n  return (audioElement as any)\n    .setSinkId(deviceInfo.browserAudioOutputId)\n    .then(() => {\n      var success =\n        (audioElement as any).sinkId === deviceInfo.browserAudioOutputId;\n      return success;\n    });\n}\n\n/**\n * Checks if a Jabra Input device is in fact selected in a media stream.\n * The deviceInfo argument must come from getDeviceInfo or getUserDeviceMediaExt calls.\n */\nexport function isDeviceSelectedForInput(\n  mediaStream: MediaStream,\n  deviceInfo: DeviceInfo\n): boolean {\n  if (!mediaStream || !deviceInfo) {\n    throw Error(\"Call to isDeviceSelectedForInput has argument(s) missing\");\n  }\n\n  var tracks = mediaStream.getAudioTracks();\n  for (var i = 0, len = tracks.length; i < len; i++) {\n    var track = tracks[i];\n    var trackCap = track.getCapabilities();\n    if (trackCap.deviceId !== deviceInfo.browserAudioInputId) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Replacement for mediaDevices.getUserMedia that makes a best effort to select the active Jabra audio device\n * to be used for the microphone. Unlike getUserMedia this method returns a promise that\n * resolve to an object containing both a stream and the device info for the selected device.\n *\n * Optional, additional non-audio constrains (like f.x. video) can be specified as well.\n *\n * Note: Subsequently, if this method appears to succeed use the isDeviceSelectedForInput function to check\n * if the browser did in fact choose a Jabra device for the microphone.\n */\nexport function getUserDeviceMediaExt(\n  constraints?: MediaStreamConstraints\n): Promise<MediaStreamAndDeviceInfoPair> {\n  // Good error if using old browser:\n  if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {\n    return Promise.reject(\n      new Error(\"Your browser does not support required media api\")\n    );\n  }\n\n  // Init completed ?\n  if (!initState.initialized) {\n    return Promise.reject(new Error(\"Browser integration not initialized\"));\n  }\n\n  // Warn of degraded UX experience unless we are running https.\n  if (location.protocol !== \"https:\") {\n    logger.warn(\n      \"This function needs to run under https for best UX experience (persisted permissions)\"\n    );\n  }\n\n  // Check input validity:\n  if (\n    constraints !== undefined &&\n    constraints !== null &&\n    typeof constraints !== \"object\"\n  ) {\n    return Promise.reject(\n      new Error(\"Optional constraints parameter must be an object\")\n    );\n  }\n\n  /**\n   * Utility method that combines constraints with ours taking precedence (deep).\n   */\n  function mergeConstraints(\n    ours: MediaStreamConstraints,\n    theirs?: MediaStreamConstraints\n  ): MediaStreamConstraints {\n    if (theirs !== null && theirs !== undefined && typeof ours === \"object\") {\n      let result: { [index: string]: any } = {};\n      for (var attrname in theirs) {\n        result[attrname] = (theirs as any)[attrname];\n      }\n      for (var attrname in ours) {\n        result[attrname] = mergeConstraints(\n          (ours as any)[attrname],\n          (theirs as any)[attrname]\n        );\n      } // Ours takes precedence.\n      return result;\n    } else {\n      return ours;\n    }\n  }\n\n  // If we have the input device id already we can do a direct call to getUserMedia, otherwise we have to do\n  // an initial general call to getUserMedia just get access to looking up the input device and then a second\n  // call to getUserMedia to make sure the Jabra input device is selected.\n  return navigator.mediaDevices\n    .getUserMedia(mergeConstraints({ audio: true }, constraints))\n    .then(dummyStream => {\n      return _doGetActiveSDKDevice_And_BrowserDevice().then(deviceInfo => {\n        // Shutdown initial dummy stream (not sure it is really required but let's be nice).\n        dummyStream.getTracks().forEach(track => {\n          track.stop();\n        });\n\n        if (deviceInfo && deviceInfo.browserAudioInputId) {\n          return navigator.mediaDevices\n            .getUserMedia(\n              mergeConstraints(\n                { audio: { deviceId: deviceInfo.browserAudioInputId } },\n                constraints\n              )\n            )\n            .then(stream => {\n              return {\n                stream: stream,\n                deviceInfo: deviceInfo\n              };\n            });\n        } else {\n          return Promise.reject(\n            new Error(\"Could not find a Jabra device with a microphone\")\n          );\n        }\n      });\n    });\n}\n\n/**\n * Internal helper for add media information properties to existing SDK device information.\n */\nfunction fillInMatchingMediaInfo(\n  deviceInfo: DeviceInfo,\n  mediaDevices: MediaDeviceInfo[]\n): void {\n  function findBestMatchIndex(\n    sdkDeviceName: string,\n    mediaDeviceNameCandidates: string[]\n  ): number {\n    // Edit distance helper adapted from\n    // https://stackoverflow.com/questions/10473745/compare-strings-javascript-return-of-likely\n    function editDistance(s1: string, s2: string) {\n      s1 = s1.toLowerCase();\n      s2 = s2.toLowerCase();\n\n      var costs = new Array();\n      for (var i = 0; i <= s1.length; i++) {\n        var lastValue = i;\n        for (var j = 0; j <= s2.length; j++) {\n          if (i == 0) costs[j] = j;\n          else {\n            if (j > 0) {\n              var newValue = costs[j - 1];\n              if (s1.charAt(i - 1) != s2.charAt(j - 1))\n                newValue =\n                  Math.min(Math.min(newValue, lastValue), costs[j]) + 1;\n              costs[j - 1] = lastValue;\n              lastValue = newValue;\n            }\n          }\n        }\n        if (i > 0) costs[s2.length] = lastValue;\n      }\n      return costs[s2.length];\n    }\n\n    // Levenshtein distance helper adapted from\n    // https://stackoverflow.com/questions/10473745/compare-strings-javascript-return-of-likely\n    function levenshteinDistance(s1: string, s2: string): number {\n      let longer = s1;\n      let shorter = s2;\n      if (s1.length < s2.length) {\n        longer = s2;\n        shorter = s1;\n      }\n      let longerLength = longer.length;\n      if (longerLength === 0) {\n        return 1.0;\n      }\n      return (longerLength - editDistance(longer, shorter)) / longerLength;\n    }\n\n    if (mediaDeviceNameCandidates.length == 1) {\n      return 0;\n    } else if (mediaDeviceNameCandidates.length > 0) {\n      let similarities = mediaDeviceNameCandidates.map(candidate => {\n        if (candidate.includes(\"(\" + sdkDeviceName + \")\")) {\n          return 1.0;\n        } else {\n          // Remove Standard/Default prefix from label in Chrome when comparing\n          let prefixEnd = candidate.indexOf(\" - \");\n          let cleanedCandidate =\n            prefixEnd >= 0 ? candidate.substring(prefixEnd + 3) : candidate;\n\n          return levenshteinDistance(sdkDeviceName, cleanedCandidate);\n        }\n      });\n      let bestMatchIndex = similarities.reduce(\n        (prevIndexMax, value, i, a) =>\n          value > a[prevIndexMax] ? i : prevIndexMax,\n        0\n      );\n      return bestMatchIndex;\n    } else {\n      return -1;\n    }\n  }\n\n  // Find matching pair input or output device.\n  function findMatchingMediaDevice(\n    groupId: string,\n    kind: string,\n    src: MediaDeviceInfo[]\n  ): MediaDeviceInfo | undefined {\n    return src.find(md => md.groupId == groupId && md.kind == kind);\n  }\n\n  if (deviceInfo && deviceInfo.deviceName) {\n    let groupId: string | undefined = undefined;\n    let audioInputId: string | undefined = undefined;\n    let audioOutputId: string | undefined = undefined;\n    let label: string | undefined = undefined;\n    // Filter out non Jabra input/output devices:\n    let jabraMediaDevices = mediaDevices.filter(\n      device =>\n        device.label &&\n        device.label.toLowerCase().includes(\"jabra\") &&\n        (device.kind === \"audioinput\" || device.kind === \"audiooutput\")\n    );\n    let someJabraDeviceIndex = findBestMatchIndex(\n      deviceInfo.deviceName,\n      jabraMediaDevices.map(md => md.label)\n    );\n    if (someJabraDeviceIndex >= 0) {\n      let foundDevice = jabraMediaDevices[someJabraDeviceIndex];\n      groupId = foundDevice.groupId;\n      label = foundDevice.label;\n      if (foundDevice.kind === \"audioinput\") {\n        audioInputId = foundDevice.deviceId;\n        // Lookup matching output device:\n        let outputDevice = findMatchingMediaDevice(\n          groupId,\n          \"audiooutput\",\n          jabraMediaDevices\n        );\n        if (outputDevice) {\n          audioOutputId = outputDevice.deviceId;\n        }\n      } else if (foundDevice.kind === \"audiooutput\") {\n        audioOutputId = foundDevice.deviceId;\n        // Lookup matching output input device:\n        let inputDevice = findMatchingMediaDevice(\n          groupId,\n          \"audioinput\",\n          jabraMediaDevices\n        );\n        if (inputDevice) {\n          audioInputId = inputDevice.deviceId;\n        }\n      }\n    }\n    if (groupId) {\n      deviceInfo.browserGroupId = groupId;\n    }\n    if (label) {\n      deviceInfo.browserLabel = label;\n    }\n    if (audioInputId) {\n      deviceInfo.browserAudioInputId = audioInputId;\n    }\n    if (audioOutputId) {\n      deviceInfo.browserAudioOutputId = audioOutputId;\n    }\n  } else {\n    // Do nothing if device information is missing.\n  }\n}\n\n/**\n * Internal helper that returns complete device information, including both SDK and browser media device\n * information for all devices.\n *\n * Chrome note:\n * 1) Only works if hosted under https.\n *\n * Firefox note:\n * 1) Output devices not supported yet. See \"https://bugzilla.mozilla.org/show_bug.cgi?id=934425\"\n * 2) The user must have provided permission to use the specific device to use it as a constraint.\n * 3) GroupId not supported.\n *\n * General non-chrome browser note:\n * 1) Returning output devices requires support for new Audio Output Devices API.\n */\nfunction _doGetSDKDevices_And_BrowserDevice(): Promise<\n  ReadonlyArray<DeviceInfo>\n> {\n  // Good error if using old browser:\n  if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {\n    return Promise.reject(\n      new Error(\"Your browser does not support required media api\")\n    );\n  }\n\n  // Init completed ?\n  if (!initState.initialized) {\n    return Promise.reject(new Error(\"Browser integration not initialized\"));\n  }\n\n  // Browser security rules (for at least chrome) requires site to run under https for labels to be read.\n  if (location.protocol !== \"https:\") {\n    return Promise.reject(\n      new Error(\"Your browser needs https for lookup to work\")\n    );\n  }\n\n  return Promise.all([\n    _doGetSDKDevices(),\n    navigator.mediaDevices.enumerateDevices()\n  ]).then(([deviceInfos, mediaDevices]) => {\n    deviceInfos.forEach(deviceInfo => {\n      fillInMatchingMediaInfo(deviceInfo, mediaDevices);\n    });\n\n    return deviceInfos;\n  });\n}\n\n/**\n * Internal helper that returns complete device information, including both SDK and browser media device\n * information for active device.\n *\n * Chrome note:\n * 1) Only works if hosted under https.\n *\n * Firefox note:\n * 1) Output devices not supported yet. See \"https://bugzilla.mozilla.org/show_bug.cgi?id=934425\"\n * 2) The user must have provided permission to use the specific device to use it as a constraint.\n * 3) GroupId not supported.\n *\n * General non-chrome browser note:\n * 1) Returning output devices requires support for new Audio Output Devices API.\n */\nfunction _doGetActiveSDKDevice_And_BrowserDevice(): Promise<DeviceInfo> {\n  // Good error if using old browser:\n  if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {\n    return Promise.reject(\n      new Error(\"Your browser does not support required media api\")\n    );\n  }\n\n  // Init completed ?\n  if (!initState.initialized) {\n    return Promise.reject(new Error(\"Browser integration not initialized\"));\n  }\n\n  // Browser security rules (for at least chrome) requires site to run under https for labels to be read.\n  if (location.protocol !== \"https:\") {\n    return Promise.reject(\n      new Error(\"Your browser needs https for lookup to work\")\n    );\n  }\n\n  // enumerateDevices requires user to have provided permission using getUserMedia for labels to be filled out.\n  return Promise.all([\n    _doGetActiveSDKDevice(),\n    navigator.mediaDevices.enumerateDevices()\n  ]).then(([deviceInfo, mediaDevices]) => {\n    fillInMatchingMediaInfo(deviceInfo, mediaDevices);\n    return deviceInfo;\n  });\n}\n\n/**\n * Helper that pass boolean values through and parses strings to booleans.\n */\nfunction booleanOrString(arg: boolean | string): boolean {\n  if (\n    arg !== \"\" &&\n    (typeof arg === \"string\" || (arg as any) instanceof String)\n  ) {\n    return arg === \"true\" || arg === \"1\";\n  } else if (typeof arg === \"boolean\") {\n    return arg;\n  } else {\n    throw new Error(\"Illegal/missing argument - boolean or string expected\");\n  }\n}\n\n/**\n * Helper that pass numbers through and parses strings to numbers.\n */\nfunction numberOrString(arg: number | string): number {\n  if (\n    arg !== \"\" &&\n    (typeof arg === \"string\" || (arg as any) instanceof String)\n  ) {\n    return parseInt(arg as string);\n  } else if (typeof arg == \"number\") {\n    return arg;\n  } else {\n    throw new Error(\"Illegal/missing argument - number or string expected\");\n  }\n}\n\n/**\n * Helper that pass color array through and converts values to color array.\n */\nfunction colorOrString(\n  arg: ReadonlyArray<number> | number | string\n): ReadonlyArray<number> {\n  if (\n    arg !== \"\" &&\n    (typeof arg === \"string\" || (arg as any) instanceof String)\n  ) {\n    let combinedValue = parseInt(arg as string, 16);\n    return [\n      (combinedValue >> 16) & 255,\n      (combinedValue >> 8) & 255,\n      combinedValue & 255\n    ];\n  } else if (typeof arg == \"number\") {\n    let combinedValue = arg;\n    return [\n      (combinedValue >> 16) & 255,\n      (combinedValue >> 8) & 255,\n      combinedValue & 255\n    ];\n  } else if (Array.isArray(arg)) {\n    if (arg.length != 3) {\n      throw new Error(\n        \"Illegal argument - wrong dimension of number array (3 expected)\"\n      );\n    }\n    return arg;\n  } else {\n    throw new Error(\n      \"Illegal/missing argument - number array or hex string expected\"\n    );\n  }\n}\n\n/**\n * Hidden implementation code for device analytics.\n */\n\n// namespace DeviceAnalyticsInternals {\n//   enum EventType {\n//     BoomArmEvent,\n//     TxLevelEvent,\n//     RxLevelEvent,\n//     TxLevelPeakEvent,\n//     RxLevelPeakEvent,\n//     RxSpeechEvent,\n//     TxSpeechEvent,\n//     StartCallEvent,\n//     EndCallEvent,\n//     BadMicDetectFlagEvent\n//   }\n\n//   interface TimedData {\n//     eventType: EventType;\n//     ticks: number;\n//     i: number;\n//     b: boolean;\n//   }\n\n//   // @ts-ignore\n//   function compareTimedData(a: TimedData, b: TimedData) {\n//     // First sort by time.\n//     let timeComp = Math.sign(a.ticks - b.ticks);\n\n//     // Secondly sort so start/end events are first/last (surround other events).\n//     if (timeComp == 0 && a.eventType != b.eventType) {\n//       if (\n//         a.eventType == EventType.StartCallEvent ||\n//         b.eventType == EventType.EndCallEvent\n//       ) {\n//         return -1;\n//       } else if (\n//         a.eventType == EventType.EndCallEvent ||\n//         b.eventType == EventType.StartCallEvent\n//       ) {\n//         return +1;\n//       }\n//     }\n\n//     return timeComp;\n//   }\n\n//   export class DeviceAnalytics {\n//     // @ts-ignore\n//     private sortedTimedEvents: TimedData[];\n\n//     static readonly MaxElementsInCall = 20000;\n//     static readonly MaxElementsAddedOutsideCall = 400;\n\n//     // @ts-ignore\n//     private startCallIndex: number = -1;\n//     // @ts-ignore\n//     private endCallIndex: number = -1;\n\n//     // @ts-ignore\n//     constructor(deviceId: number) {\n//       this.sortedTimedEvents = new Array<TimedData>();\n//     }\n//   }\n// }\n\n/**\n * Public Analytics API as a class that clients must expressly instantiate to use.\n */\n// export class Analytics {\n//   private deviceAnalyticsPerDeviceId: Map<\n//     number,\n//     DeviceAnalyticsInternals.DeviceAnalytics\n//   >;\n\n//   constructor() {\n//     this.deviceAnalyticsPerDeviceId = new Map<\n//       number,\n//       DeviceAnalyticsInternals.DeviceAnalytics\n//     >();\n\n//     // Auto-subscribe for devlog events.\n//     addEventListener('devlog', event => {\n//       let deviceAnalytics = this.deviceAnalyticsPerDeviceId.get(\n//         event.data.deviceID\n//       );\n//       if (!deviceAnalytics) {\n//         this.deviceAnalyticsPerDeviceId.set(\n//           event.data.deviceID,\n//           (deviceAnalytics = new DeviceAnalyticsInternals.DeviceAnalytics(\n//             event.data.deviceID\n//           ))\n//         );\n//       }\n\n//       // TODO: Impl.\n//     });\n//   }\n\n//   // TODO Finish API here.\n// }\n","'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n","export type JabraEventType =\n  | \"Speech_Analysis_TX\"\n  | \"Speech_Analysis_RX\"\n  | \"TX Acoustic Logging Level\"\n  | \"RX Acoustic Logging Level\"\n  | \"TX Acoustic Logging Peak\"\n  | \"RX Acoustic Logging Peak\"\n  | \"Boom Position Guidance OK\"\n  | \"Bad_Mic_detect Flag\"\n  | \"Mute State\";\n\nexport type AnalyticsEventType =\n  | \"txspeech\"\n  | \"rxspeech\"\n  | \"txacousticlevel\"\n  | \"rxacousticlevel\"\n  | \"txacousticpeak\"\n  | \"rxacousticpeak\"\n  | \"armpositionok\"\n  | \"badmic\"\n  | \"mute\";\n\nconst jabraEventTypes: {\n  [T in JabraEventType]: {\n    eventType: AnalyticsEventType;\n    valueType: \"boolean\" | \"number\";\n  }\n} = {\n  Speech_Analysis_TX: { eventType: \"txspeech\", valueType: \"boolean\" },\n  Speech_Analysis_RX: { eventType: \"rxspeech\", valueType: \"boolean\" },\n  \"TX Acoustic Logging Level\": {\n    eventType: \"txacousticlevel\",\n    valueType: \"number\"\n  },\n  \"RX Acoustic Logging Level\": {\n    eventType: \"rxacousticlevel\",\n    valueType: \"number\"\n  },\n  \"TX Acoustic Logging Peak\": {\n    eventType: \"txacousticpeak\",\n    valueType: \"number\"\n  },\n  \"RX Acoustic Logging Peak\": {\n    eventType: \"rxacousticpeak\",\n    valueType: \"number\"\n  },\n  \"Boom Position Guidance OK\": {\n    eventType: \"armpositionok\",\n    valueType: \"boolean\"\n  },\n  \"Bad_Mic_detect Flag\": { eventType: \"badmic\", valueType: \"boolean\" },\n  \"Mute State\": { eventType: \"mute\", valueType: \"boolean\" }\n};\n\nexport class AnalyticsEvent {\n  public type: string;\n  public value: any;\n  public timestamp: number;\n\n  constructor(type: string, value: any, timestamp?: number) {\n    this.type = type;\n    this.value = value;\n    this.timestamp = timestamp || Date.now();\n  }\n}\n\nexport function createAnalyticsEvent(event: any): AnalyticsEvent | null {\n  if (\"ID\" in event.data) {\n    switch (event.data.ID) {\n      case \"VOLUP TAP\":\n        return new AnalyticsEvent(\"volumeup\", true, event.data.TimeStampMs);\n      case \"VOLDOWN TAP\":\n        return new AnalyticsEvent(\"volumedown\", true, event.data.TimeStampMs);\n    }\n  }\n\n  for (const jabraEventType in jabraEventTypes) {\n    if (jabraEventType in event.data) {\n      const translation = jabraEventTypes[jabraEventType as JabraEventType];\n      let value = event.data[jabraEventType];\n\n      switch (translation.valueType) {\n        case \"boolean\":\n          value = value.toLowerCase() === \"true\";\n          break;\n        case \"number\":\n          value = Number(value);\n          break;\n        default:\n          break;\n      }\n\n      return new AnalyticsEvent(\n        translation.eventType,\n        value,\n        event.data.TimeStampMs\n      );\n    }\n  }\n\n  return null;\n}\n","import { AnalyticsEvent } from \"./AnalyticsEvent\";\n\nexport type AnalyticsEventLogListFilter = {\n  eventType?: string;\n  limit?: number;\n  limitEvent?: AnalyticsEvent;\n  offsetEvent?: AnalyticsEvent;\n  interval?: { start: number; end: number };\n};\n\nexport class AnalyticsEventLog {\n  // An array of events sorted by the time it was emitted.\n  private events: AnalyticsEvent[] = [];\n\n  // Asuming this.events is sorted, add an event while maintaining order.\n  public add(event: AnalyticsEvent): AnalyticsEvent {\n    // Find the index of the first event older than current event.\n    let index = this.events.findIndex(e => {\n      return event.timestamp < e.timestamp;\n    });\n\n    // If event is older than any other event, add to back of event log\n    if (index === -1) index = this.events.length;\n\n    // Add all events before current event, current event, and all events after\n    // current event\n    this.events = [\n      ...this.events.slice(0, index),\n      event,\n      ...this.events.slice(index)\n    ];\n\n    // Return parsed AnalyticsEvent\n    return event;\n  }\n\n  /**\n   * Get the newest event in the events log, optionally fitler by eventType\n   *\n   * @param {string} [eventType]\n   * @returns newest event\n   * @memberof AnalyticsEventLog\n   */\n  public newest(eventType?: string) {\n    // If eventType has been specified return last event with that type\n    if (eventType) {\n      for (let i = this.events.length - 1; i > 0; i--) {\n        const event = this.events[i];\n\n        if (event.type === eventType) return event;\n      }\n\n      return null;\n    }\n\n    // Else return last event of array\n    return this.events[this.events.length - 1] || null;\n  }\n\n  /**\n   *\n   *\n   * @param {AnalyticsEventLogListFilter} [filter]\n   * @returns matching list of events\n   * @memberof AnalyticsEventLog\n   */\n  public list(filter?: AnalyticsEventLogListFilter) {\n    let events = this.events;\n\n    if (filter) {\n      const { eventType, limit, interval, limitEvent, offsetEvent } = filter;\n\n      if (limitEvent) {\n        events = events.slice(0, this.events.indexOf(limitEvent));\n      }\n\n      if (offsetEvent) {\n        events = events.slice(this.events.indexOf(offsetEvent));\n      }\n\n      if (eventType || interval) {\n        events = events.filter(({ type, timestamp }) => {\n          if (eventType && !eventType.includes(type)) return false;\n          if (interval && interval.start && timestamp < interval.start)\n            return false;\n          if (interval && interval.end && timestamp > interval.end)\n            return false;\n\n          return true;\n        });\n      }\n\n      if (limit) {\n        events = limit > 0 ? events.slice(0, limit) : events.slice(limit);\n      }\n    }\n\n    return events;\n  }\n\n  public clear() {\n    this.events = [];\n  }\n}\n","import EventEmitter from \"eventemitter3\";\n\nimport * as Jabra from \"../jabra.browser.integration-2.1\";\nimport { AnalyticsEvent, createAnalyticsEvent } from \"./AnalyticsEvent\";\nimport {\n  AnalyticsEventLog,\n  AnalyticsEventLogListFilter\n} from \"./AnalyticsEventLog\";\n\nexport class Analytics extends EventEmitter {\n  private events = new AnalyticsEventLog();\n\n  public startTime: number | undefined;\n  public stopTime: number | undefined;\n\n  constructor() {\n    super();\n\n    Jabra.addEventListener(\"devlog\", (devlogEvent: any) => {\n      // opt out if not running\n      if (!this.startTime || this.stopTime) return;\n      // Since devlog events can be recieved out of order, add event to the\n      // event log, which will maintain an ordered list of events.\n      const event = createAnalyticsEvent(devlogEvent);\n\n      if (event) {\n        this.events.add(event);\n        this.emit(event.type, event);\n      }\n    });\n  }\n\n  public start() {\n    this.startTime = Date.now();\n    this.stopTime = undefined;\n  }\n\n  public stop() {\n    this.stopTime = Date.now();\n  }\n\n  public clear() {\n    this.events.clear();\n  }\n\n  public getSpeechStatus() {\n    const txspeech = this.events.newest(\"txspeech\");\n    const rxspeech = this.events.newest(\"rxspeech\");\n    const isTXSpeaking = txspeech ? txspeech.value : false;\n    const isRXSpeaking = rxspeech ? rxspeech.value : false;\n    const isCrosstalking = isTXSpeaking && isRXSpeaking;\n    const isSilent = !isTXSpeaking && !isRXSpeaking;\n\n    return {\n      isSilent,\n      isCrosstalking,\n      isTXSpeaking: isCrosstalking ? false : isTXSpeaking,\n      isRXSpeaking: isCrosstalking ? false : isRXSpeaking\n    };\n  }\n\n  public getSpeechTime(fromTime?: number, toTime?: number) {\n    const query: {\n      eventType: string;\n      interval?: AnalyticsEventLogListFilter[\"interval\"];\n    } = { eventType: \"txspeech rxspeech\" };\n\n    if (fromTime && toTime) {\n      query.interval = { start: fromTime, end: toTime };\n    }\n\n    let events = this.events.list(query);\n    const startTime = fromTime || this.startTime || 0;\n    const endTime = toTime || this.stopTime || Date.now();\n\n    let txDuration = 0;\n    let txStartEvent: any | undefined;\n\n    let rxDuration = 0;\n    let rxStartEvent: any | undefined;\n\n    let crosstalkDuration = 0;\n    let crosstalkStartEvent: any | undefined;\n\n    if (fromTime && toTime) {\n      const firstTXEventBeforeInterval = this.events.list({\n        eventType: \"txspeech\",\n        limitEvent: events[0],\n        limit: -1\n      })[0];\n      const firstRXEventBeforeInterval = this.events.list({\n        eventType: \"rxspeech\",\n        limitEvent: events[0],\n        limit: -1\n      })[0];\n\n      // if tx was speaking before interval, we assume they are still speaking,\n      // and add an event to the event list with the timestamp being the\n      // startTime of the interval\n      if (\n        firstTXEventBeforeInterval &&\n        firstTXEventBeforeInterval.value === true\n      ) {\n        events.unshift(new AnalyticsEvent(\"txspeech\", true, startTime));\n      }\n\n      // if rx was speaking before interval, we assume they are still speaking,\n      // and add an event to the event list with the timestamp being the\n      // startTime of the interval\n      if (\n        firstRXEventBeforeInterval &&\n        firstRXEventBeforeInterval.value === true\n      ) {\n        events.unshift(new AnalyticsEvent(\"rxspeech\", true, startTime));\n      }\n\n      // to ensure correct calculations we pad stopping events, to the end of\n      // the events list\n      events.push(\n        new AnalyticsEvent(\"txspeech\", false, endTime),\n        new AnalyticsEvent(\"rxspeech\", false, endTime)\n      );\n    }\n\n    for (let event of events) {\n      const isTXEvent = event.type === \"txspeech\";\n      const isRXEvent = event.type === \"rxspeech\";\n\n      // if tx starts talking, and isn't already talking, mark start event\n      if (isTXEvent && event.value === true && !txStartEvent) {\n        txStartEvent = event;\n      }\n\n      // if rx starts talking, and isn't already talking, mark start event\n      if (isRXEvent && event.value === true && !rxStartEvent) {\n        rxStartEvent = event;\n      }\n\n      // if tx stops talking, and has been talking\n      if (isTXEvent && event.value === false && txStartEvent) {\n        // if has been crosstalking, add to crosstalk duration\n        if (crosstalkStartEvent) {\n          crosstalkDuration += event.timestamp - crosstalkStartEvent.timestamp;\n          crosstalkStartEvent = undefined;\n\n          // mark event as new start event for rx\n          if (rxStartEvent) rxStartEvent = event;\n        }\n        // if hasn't been crosstalking, add to tx duration\n        else {\n          txDuration += event.timestamp - txStartEvent.timestamp;\n        }\n\n        txStartEvent = undefined;\n      }\n\n      // if rx stops talking, and has been talking\n      if (isRXEvent && event.value === false && rxStartEvent) {\n        // if has been crosstalking, add to crosstalk duration\n        if (crosstalkStartEvent) {\n          crosstalkDuration += event.timestamp - crosstalkStartEvent.timestamp;\n          crosstalkStartEvent = undefined;\n          if (txStartEvent) txStartEvent = event;\n        }\n        // if hasn't been crosstalking, add to rx duration\n        else {\n          rxDuration += event.timestamp - rxStartEvent.timestamp;\n        }\n\n        rxStartEvent = undefined;\n      }\n\n      // if both tx and rx is talking,\n      if (txStartEvent && rxStartEvent && !crosstalkStartEvent) {\n        // mark event as the start of crosstalk\n        crosstalkStartEvent = event;\n\n        // if tx started crosstalk, add duration to rx duration\n        if (isTXEvent) {\n          rxDuration += event.timestamp - rxStartEvent.timestamp;\n        }\n\n        // if rx started crosstalk, add duration to tx duration\n        if (isRXEvent) {\n          txDuration += event.timestamp - txStartEvent.timestamp;\n        }\n      }\n    }\n\n    const totalTime = endTime - startTime;\n    const silenceTime =\n      totalTime - (txDuration + rxDuration + crosstalkDuration);\n\n    const calculatePercentage = (duration: number) => {\n      const pct = (100 * duration) / totalTime;\n      //@ts-ignore\n      return +(Math.round(pct + \"e+2\") + \"e-2\");\n    };\n\n    return {\n      totalTime,\n      txSpeechTime: txDuration,\n      txSpeechTimePct: calculatePercentage(txDuration),\n      rxSpeechTime: rxDuration,\n      rxSpeechTimePct: calculatePercentage(rxDuration),\n      crosstalkTime: crosstalkDuration,\n      crosstalkTimePct: calculatePercentage(crosstalkDuration),\n      silenceTime: silenceTime,\n      silenceTimePct: calculatePercentage(silenceTime)\n    };\n  }\n\n  getMutedStatus(): boolean {\n    const event = this.events.newest(\"mute\");\n    return event ? event.value : false;\n  }\n  getMutedCount(): number {\n    return this.events.list({ eventType: \"mute\" }).filter(event => event.value)\n      .length;\n  }\n\n  getBoomArmStatus(): boolean | undefined {\n    const event = this.events.newest(\"boomarm\");\n    return event ? event.value : undefined;\n  }\n  getBoomArmMisalignedCount(): number {\n    return this.events\n      .list({ eventType: \"boomarm\" })\n      .filter(event => event.value).length;\n  }\n\n  getVolumeUpCount(): number {\n    return this.events\n      .list({ eventType: \"volumeup\" })\n      .filter(event => event.value).length;\n  }\n  getVolumeDownCount(): number {\n    return this.events\n      .list({ eventType: \"volumedown\" })\n      .filter(event => event.value).length;\n  }\n\n  getAudioExposure(limit: number = -15): AnalyticsEvent[] {\n    return this.events.list({ limit, eventType: \"rxacousticlevel\" });\n  }\n  getAverageAudioExposure(fromTime?: number, toTime?: number): number {\n    const eventType = \"rxacousticlevel\";\n\n    let events: AnalyticsEvent[] = [];\n\n    if (fromTime && toTime) {\n      const eventsWithinInterval = this.events.list({\n        eventType,\n        interval: { start: fromTime, end: toTime }\n      });\n      const firstEventBeforeInterval = this.events.list({\n        eventType,\n        limitEvent: eventsWithinInterval[0],\n        limit: -1\n      });\n\n      events = [...firstEventBeforeInterval, ...eventsWithinInterval];\n    } else {\n      events = this.events.list({\n        eventType\n      });\n    }\n\n    // If no events was found, the headset hasn't reported an acoustic level yet\n    if (events.length === 0) return 0;\n    // If only one event was found, the average is the value of event\n    if (events.length === 1) return events[0].value;\n\n    let sum = 0;\n    let totalWeight = 0;\n\n    // Iterate every event and calculate sum and weight\n    for (let i = 0; i < events.length - 1; i++) {\n      const eventA = events[i];\n      const eventB = events[i + 1];\n      // weight is the number of miliseconds the acoustic level as active\n      const weight = eventB.timestamp - eventA.timestamp;\n\n      sum += weight * eventA.value;\n      totalWeight += weight;\n    }\n\n    // return the weighted average\n    return Math.round(sum / totalWeight);\n  }\n\n  getBackgroundNoise(limit: number = -15): AnalyticsEvent[] {\n    return this.events.list({ limit, eventType: \"txacousticlevel\" });\n  }\n  getAverageBackgroundNoise(fromTime?: number, toTime?: number): number {\n    const eventType = \"txacousticlevel\";\n\n    let events: AnalyticsEvent[] = [];\n\n    if (fromTime && toTime) {\n      const eventsWithinInterval = this.events.list({\n        eventType,\n        interval: { start: fromTime, end: toTime }\n      });\n      const firstEventBeforeInterval = this.events.list({\n        eventType,\n        limitEvent: eventsWithinInterval[0],\n        limit: -1\n      });\n\n      events = [...firstEventBeforeInterval, ...eventsWithinInterval];\n    } else {\n      events = this.events.list({\n        eventType\n      });\n    }\n\n    // If no events was found, the headset hasn't reported an acoustic level yet\n    if (events.length === 0) return 0;\n    // If only one event was found, the average is the value of event\n    if (events.length === 1) return events[0].value;\n\n    let sum = 0;\n    let totalWeight = 0;\n\n    // Iterate every event and calculate sum and weight\n    for (let i = 0; i < events.length - 1; i++) {\n      const eventA = events[i];\n      const eventB = events[i + 1];\n      // weight is the number of miliseconds the acoustic level as active\n      const weight = eventB.timestamp - eventA.timestamp;\n\n      sum += weight * eventA.value;\n      totalWeight += weight;\n    }\n\n    // return the weighted average\n    return Math.round(sum / totalWeight);\n  }\n}\n\nexport default Analytics;\n"],"names":["ErrorCodes","ErrorReturnCodes","apiVersion","isBeta","includes","prodExtensionId","betaExtensionId","commandEventsList","DeviceFeature","RemoteMmiType","RemoteMmiSequence","RemoteMmiActionInput","CommandError","constructor","command","errmessage","data","JSON","stringify","name","Error","eventListeners","Map","forEach","event","set","logLevel","logger","trace","msg","console","log","info","warn","error","apiClientId","Math","random","toString","substr","sendRequestResultMap","requestNumber","initState","init","Promise","resolve","reject","test","navigator","userAgent","vendor","initialized","initializing","clear","duringInit","notify","eventName","eventMsg","callbacks","get","callback","identifyAndCleanupResultTarget","requestId","resultTarget","delete","size","value","entries","next","undefined","mapSize","eventCallback","source","window","direction","eventApiClientId","message","startsWith","normalizedMsg","substring","parseInt","commandIndex","findIndex","e","version_jsapi","installationOk","browserSdkVersions","installInfo","version_browserextension","version_chromehost","some","v","version_nativesdk","map","betaIndex","lastIndexOf","length","filter","every","i","arr","result","dataStr","legacy_result","err","has","clientEvent","parse","normalizedError","cmd","clientError","addEventListener","setTimeout","sendCmdWithResult","then","resultStr","String","sendCmd","catch","shutdown","removeEventListener","key","getEvents","nameSpec","Array","isArray","Set","concat","apply","a","RegExp","from","keys","find","c","push","splice","ring","offHook","onHook","mute","unmute","hold","resume","setMmiFocus","type","capture","numberOrString","booleanOrString","setRemoteMmiLightAction","color","effect","arg","combinedValue","colorOrString","_doGetActiveSDKDevice","_doGetSDKDevices","getActiveDevice","includeBrowserMediaDeviceInfo","_doGetActiveSDKDevice_And_BrowserDevice","getDevices","mediaDevices","enumerateDevices","location","protocol","all","ref","deviceInfos","deviceInfo","fillInMatchingMediaInfo","_setActiveDeviceId","id","idVal","setActiveDeviceId","setBusyLight","busy","getInstallInfo","args","requireInitializedCheck","postMessage","trySetDeviceOutput","audioElement","setSinkId","browserAudioOutputId","sinkId","isDeviceSelectedForInput","mediaStream","tracks","getAudioTracks","len","getCapabilities","deviceId","browserAudioInputId","getUserDeviceMediaExt","constraints","getUserMedia","mergeConstraints","ours","theirs","attrname","audio","dummyStream","getTracks","track","stop","stream","findMatchingMediaDevice","groupId","kind","src","md","deviceName","audioInputId","audioOutputId","label","jabraMediaDevices","device","toLowerCase","someJabraDeviceIndex","sdkDeviceName","mediaDeviceNameCandidates","candidate","prefixEnd","indexOf","cleanedCandidate","s1","s2","longer","shorter","longerLength","costs","lastValue","j","newValue","charAt","min","editDistance","levenshteinDistance","reduce","prevIndexMax","foundDevice","outputDevice","inputDevice","browserGroupId","browserLabel","Object","prototype","hasOwnProperty","prefix","Events","EE","fn","context","once","this","addListener","emitter","TypeError","listener","evt","_events","_eventsCount","clearEvent","EventEmitter","create","__proto__","eventNames","events","names","call","slice","getOwnPropertySymbols","listeners","handlers","l","ee","listenerCount","emit","a1","a2","a3","a4","a5","arguments","removeListener","on","removeAllListeners","off","prefixed","module","jabraEventTypes","Speech_Analysis_TX","eventType","valueType","Speech_Analysis_RX","AnalyticsEvent","timestamp","Date","now","AnalyticsEventLog","add","index","newest","let","list","limitEvent","offsetEvent","interval","start","end","limit","Analytics","Jabra","devlogEvent","startTime","stopTime","ID","TimeStampMs","const","jabraEventType","translation","Number","createAnalyticsEvent","getSpeechStatus","txspeech","rxspeech","isTXSpeaking","isRXSpeaking","isCrosstalking","getSpeechTime","fromTime","toTime","query","txStartEvent","rxStartEvent","crosstalkStartEvent","endTime","txDuration","rxDuration","crosstalkDuration","firstTXEventBeforeInterval","firstRXEventBeforeInterval","unshift","isTXEvent","isRXEvent","totalTime","silenceTime","calculatePercentage","duration","round","txSpeechTime","txSpeechTimePct","rxSpeechTime","rxSpeechTimePct","crosstalkTime","crosstalkTimePct","silenceTimePct","getMutedStatus","getMutedCount","getBoomArmStatus","getBoomArmMisalignedCount","getVolumeUpCount","getVolumeDownCount","getAudioExposure","getAverageAudioExposure","eventsWithinInterval","sum","totalWeight","eventA","weight","getBackgroundNoise","getAverageBackgroundNoise"],"mappings":"IAiSYA,EA0BAC,EA7RCC,EAAa,cAKpBC,EAASD,EAAWE,SAAS,QAK7BC,EAAkB,mCAKlBC,EAAkB,mCAiGlBC,EAAoB,CACxB,UACA,eACA,iBACA,UACA,cACA,mBACA,eACA,4BA2IF,SAAYP,GACVA,yBACAA,2BACAA,6BACAA,mCACAA,qCACAA,+BACAA,+BACAA,yCACAA,6CACAA,6CACAA,0CACAA,wCACAA,oDACAA,4CACAA,4CACAA,4CACAA,sCACAA,0CACAA,0CACAA,0DApBF,CAAYA,IAAAA,OA0BZ,SAAYC,GACVA,6BACAA,uCACAA,uCACAA,qCACAA,mDACAA,uDACAA,uCACAA,iDACAA,2CACAA,2CACAA,kDACAA,oCACAA,0CACAA,wCACAA,gDACAA,kDACAA,8CACAA,gDACAA,oCACAA,sDACAA,sEACAA,0DACAA,kDACAA,kEACAA,0CACAA,4DACAA,gEA3BF,CAAYA,IAAAA,WAuKAO,EAwBAC,EA2BAC,EAUAC,EAnMCC,cAKXC,WAAYC,EAAiBC,EAAoBC,eAE7C,WACEF,EACA,+BACAC,EACA,iBACAE,KAAKC,UAAUF,GAAQ,UAEtBF,QAAUA,OACVC,WAAaA,OACbC,KAAOA,OACPG,KAAO,sGAjBkBC,OA6H5BC,EAAuD,IAAIC,IAnPlB,CAC7C,OACA,SACA,kBACA,kBACA,aACA,UACA,SACA,QACA,SACA,UACA,WACA,WACA,SACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,OACA,UACA,WACA,WACA,SACA,YACA,YACA,WACA,aACA,YACA,mBACA,gBACA,UACA,UACA,UACA,WACA,aACA,YACA,iBACA,oBACA,eACA,kBACA,oBACA,uBACA,SACA,YACA,cACA,gBACA,YACA,MACA,SAkMaC,iBAASC,UAAqBH,EAAeI,IAAID,EAAO,MAKvE,SAAYhB,GACVA,+BACAA,sCACAA,oCACAA,gCACAA,0CACAA,oEACAA,8BACAA,gCACAA,kCACAA,0CACAA,oCACAA,oEACAA,kFACAA,oCACAA,4BACAA,0EACAA,0CACAA,sCAlBF,CAAYA,IAAAA,OAwBZ,SAAYC,GACVA,mCACAA,uCACAA,2CACAA,mCACAA,mCACAA,2CACAA,2CACAA,qCACAA,qCACAA,6CACAA,4CACAA,gDACAA,wCACAA,4CACAA,sCACAA,sCACAA,oCACAA,gDACAA,sCACAA,sCACAA,qCArBF,CAAYA,IAAAA,OA2BZ,SAAYC,GACVA,mDACAA,iDACAA,qDACAA,qDAJF,CAAYA,IAAAA,OAUZ,SAAYC,GACVA,qCACAA,yCACAA,uCACAA,qDACAA,4CACAA,sDACAA,0DAPF,CAAYA,IAAAA,WAoBDe,EAAmB,EAKxBC,EAAS,gDACbC,eAAMC,GACAH,GAAY,GACdI,QAAQC,IAAIF,gBAIhBG,cAAKH,GACCH,GAAY,GACdI,QAAQC,IAAIF,gBAIhBI,cAAKJ,GACCH,GAAY,GACdI,QAAQG,KAAKJ,gBAIjBK,eAAML,GACAH,GAAY,GACdI,QAAQI,MAAML,UASdM,EAAsBC,KAAKC,SAC9BC,SAAS,IACTC,OAAO,EAAG,GAMPC,EAAsD,IAAIlB,IAQ5DmB,EAAwB,EAKxBC,EAIA,GAMJ,SAAgBC,WACP,IAAIC,iBAASC,EAASC,OAGzB,SAASC,KAAKC,UAAUC,aAAc,aAAaF,KAAKC,UAAUE,eAE3DJ,EACL,IAAI1B,MACF,2GAKFsB,EAAUS,aAAeT,EAAUU,oBAC9BN,EAAO,IAAI1B,MAAM,kDAG1BsB,EAAUU,cAAe,EACzBZ,EAAqBa,YACjBC,GAAa,WA+NRC,EACPC,EACAC,OAEIC,EAAYrC,EAAesC,IAAIH,GAC/BE,EACFA,EAAUnC,iBAAQqC,GAChBA,EAASH,KAKX9B,EAAOO,MAAM,iCAAmCsB,YAQ3CK,EACPC,OAIIC,KACAD,EACFC,EAAevB,EAAqBmB,IAAIG,GAExCtB,EAAqBwB,OAAOF,QACvB,GAAkC,IAA9BtB,EAAqByB,KAAY,KAGtCC,EAAQ1B,EAAqB2B,UAAUC,OAAOF,MAClDH,EAAeG,EAAM,GAGrB1B,EAAqBwB,OAAOE,EAAM,SAGlCH,OAAeM,MAIXC,EAAU9B,EAAqByB,YACjCK,EAAU,IAAMA,EAAU,IAAO,GAEnC3C,EAAOM,KACL,sEACEqC,EACA,KAICP,EAnRTrB,EAAU6B,uBAAiB/C,MAEvBA,EAAMgD,SAAWC,QACjBjD,EAAMR,KAAK0D,WACc,gDAAzBlD,EAAMR,KAAK0D,UACX,KACIC,EAAmBnD,EAAMR,KAAKmB,aAAe,GAC7C2B,EAAYtC,EAAMR,KAAK8C,WAAa,MAGpC3B,IAAgBwC,GAAyC,KAArBA,KACtChD,EAAOC,MACL,wCAA0CX,KAAKC,UAAUM,EAAMR,OAItC,OAAvBQ,EAAMR,KAAK4D,gBACNpD,EAAMR,KAAK4D,QAIhBpD,EAAMR,KAAK4D,SAAWpD,EAAMR,KAAK4D,QAAQC,WAAW,YACtDrD,EAAMR,KAAKkB,MAAQV,EAAMR,KAAK4D,eACvBpD,EAAMR,KAAK4D,SAGhBpD,EAAMR,KAAK4D,QAAS,CACtBjD,EAAOC,MAAM,gBAAkBX,KAAKC,UAAUM,EAAMR,WAC9C8D,EAAwBtD,EAAMR,KAAK4D,QAAQG,UAAU,MAEvDD,EAAcD,WAAW,mBAC3BnD,EAAWsD,SAASxD,EAAMR,KAAK4D,QAAQG,UAAU,UACjDpD,EAAOC,MAAM,uBAAyBF,OAOlCuD,EAAe1E,EAAkB2E,mBAAUC,UAC/CL,EAAcD,WAAWM,QAEvBF,GAAgB,EAAG,EAGD,mBAAlBH,GACAA,EAAcD,WAAW,eAGpBrD,EAAMR,KAAKA,OACdQ,EAAMR,KAAKA,KAAO,IAEpBQ,EAAMR,KAAKA,KAAKoE,cAAgBlF,GAIZ,mBAAlB4E,IACFtD,EAAMR,KAAKA,KAAKqE,kBAiItBC,EAAqB,EADDC,EA/HZ/D,EAAMR,KAAKA,MAiITwE,yBACZD,EAAYE,mBACZF,EAAYH,gBAISM,cAAKC,UAAMA,MAAOJ,EAAYK,oBAMlDN,EACEO,aAAIF,OACCG,EAAYH,EAAEI,YAAY,eAC1BD,GAAa,GAAKH,EAAEK,OAASF,EAAY,EACpCH,EAAEpD,OAAOuD,EAAY,YAK/BG,gBAAON,UAAKA,IAEZO,eAAOP,EAAGQ,EAAGC,UAAQT,IAAMS,EAAI,WAnJxBrC,EAAeF,EAA+BC,MAC9CC,EAAc,KACZsC,KACA7E,EAAMR,KAAKA,KACbqF,EAAS7E,EAAMR,KAAKA,SACf,KAEDsF,EAAUxB,EAAcC,UADTxE,EAAkB0E,GAAce,OAAS,GAE5DK,EAAS,GACLC,IACFD,EAAOE,cAAgBD,GAI3BvC,EAAalB,QAAQwD,OAChB,KACDG,EACF,iDACAhF,EAAMR,KAAK4D,QACX,4IACFjD,EAAOO,MAAMsE,GACbjD,EAAO,QAAS,CACdrB,MAAOsE,EACP5B,QAASpD,EAAMR,KAAK4D,eAGnB,CAAA,IAAIvD,EAAeoF,IAAI3B,UAW5BnD,EAAOM,KAAK,oBAAsBT,EAAMR,KAAK4D,cAC7CrB,EAAO,QAAS,CACdrB,MAAO,oBACP0C,QAASpD,EAAMR,KAAK4D,cAblB8B,EAA6BzF,KAAK0F,MACpC1F,KAAKC,UAAUM,EAAMR,cAEhB0F,EAAYhC,iBACZgC,EAAYvE,mBACZuE,EAAY5C,UACnB4C,EAAY9B,QAAUE,EAEtBvB,EAAOuB,EAA4B4B,MAWjCpD,SACFA,GAAa,EACNT,SAEJ,GAAIrB,EAAMR,KAAKkB,MAAO,CAC3BP,EAAOO,MAAM,cAAgBV,EAAMR,KAAKkB,WAClC0E,EAA0BpF,EAAMR,KAAKkB,MAAM6C,UAAU,GAGvDhB,EAAeF,EAA+BC,MAC9CC,EACFA,EAAajB,OACX,IAAIlC,EACFmD,EAAa8C,IACbD,EACApF,EAAMR,KAAKA,WAGV,KACD8F,EAA2B7F,KAAK0F,MAClC1F,KAAKC,UAAUM,EAAMR,cAEhB8F,EAAYpC,iBACZoC,EAAY3E,mBACZ2E,EAAYhD,UACnBgD,EAAY5E,MAAQ0E,EAEpBrD,EAAO,QAASuD,MAGdxD,SACFA,GAAa,EACNR,EAAO,IAAI1B,MAAMI,EAAMR,KAAKkB,aA4CnBqD,EACpBD,GAtCNb,OAAOsC,iBAAiB,UAAWrE,EAAU6B,eAG7CyC,sBACEC,EAAkB,aAAc,MAAM,GACnCC,cAAKb,OACAc,EACgB,iBAAXd,GAAuBA,aAAkBe,OAC5Cf,EACApF,KAAKC,UAAUmF,EAAQ,KAAM,GACnC1E,EAAOC,MAAM,2CAA6CuF,GAE1DE,EAAQ,WAAY,MAAM,KAE3BC,eAAMpF,GACLP,EAAOO,MAAMA,MAEhB,KAGH8E,WAAW,YACU,IAAf1D,IACFA,GAAa,EAEbR,EACE,IAAI1B,MACF,uGAHgBjB,EAASG,EAAkBD,GAKzC,gDAIP,KAkGHqC,EAAUS,aAAc,EACxBT,EAAUU,cAAe,IAQ7B,SAAgBmE,WACV7E,EAAUS,aACZsB,OAAO+C,oBAAoB,UAAW9E,EAAU6B,eAChD7B,EAAU6B,mBAAgBF,EAC1B7B,EAAqBa,QACrBZ,EAAgB,EAChBC,EAAUS,aAAc,EAIxB9B,EAAeE,iBAAS2C,EAAOuD,MAGxB7E,QAAQC,WAGVD,QAAQE,OAAO,IAAI1B,MAAM,wCAOlC,SAASsG,EACPC,UAEIC,MAAMC,QAAQF,GAET,UAEF,IAAIG,IAAY,GAAGC,OAAOC,MAAM,GAAIL,EAAS9B,aAAIoC,UAAKP,EAAUO,QAE5DN,aAAoBO,OACtBN,MAAMO,KAAa9G,EAAe+G,QAAQnC,gBAAOwB,UACtDE,EAAS5E,KAAK0E,KAIZpG,EAAeoF,IAAIkB,GACd,CAACA,IAERhG,EAAOM,KACL,iBACE0F,EACA,+CAKD,aA6BOZ,EACdY,EACA/D,GAEA8D,EAAUC,GAAU9B,aAAI1E,OAClBuC,EAAYrC,EAAesC,IAAIxC,GAC9BuC,EAAW2E,cAAKC,UAAKA,IAAM1E,KAC9BF,EAAW6E,KAAK3E,cA6BN4D,EACdG,EACA/D,GAEA8D,EAAUC,GAAU9B,aAAI1E,OAClBuC,EAAYrC,EAAesC,IAAIxC,GAC/B+D,EAAYxB,EAAWwB,mBAAUoD,UAAKA,IAAM1E,IAC5CsB,GAAa,GACfxB,EAAW8E,OAAOtD,EAAW,KAQnC,SAAgBuD,IACdpB,EAAQ,QAMV,SAAgBqB,IACdrB,EAAQ,WAMV,SAAgBsB,IACdtB,EAAQ,UAMV,SAAgBuB,IACdvB,EAAQ,QAMV,SAAgBwB,IACdxB,EAAQ,UAMV,SAAgByB,IACdzB,EAAQ,QAMV,SAAgB0B,IACd1B,EAAQ,mBAYM2B,EACdC,EACAC,UAIOjC,EAAwB,cAAe,CAC5CgC,KAHYE,EAAeF,GAI3BC,QAHeE,EAAgBF,KAiBnC,SAAgBG,EACdJ,EACAK,EACAC,UAKOtC,EAAwB,0BAA2B,CACxDgC,KAJYE,EAAeF,GAK3BK,MAgnBJ,SACEE,MAGU,KAARA,IACgB,iBAARA,GAAqBA,aAAuBpC,QACpD,KACIqC,EAAgBzE,SAASwE,EAAe,UACrC,CACJC,GAAiB,GAAM,IACvBA,GAAiB,EAAK,IACP,IAAhBA,GAEG,GAAkB,iBAAPD,QAET,CADaA,GAEA,GAAM,IAFNA,GAGA,EAAK,IACP,IAJEA,GAMf,GAAI5B,MAAMC,QAAQ2B,GAAM,IACX,GAAdA,EAAIxD,aACA,IAAI5E,MACR,0EAGGoI,QAED,IAAIpI,MACR,kEAjpBWsI,CAAcJ,GAK3BC,OAJcJ,EAAeI,KAYjC,SAASI,WACA1C,EAA8B,mBAOvC,SAAS2C,WACA3C,EAA6C,uBAYtC4C,EACdC,0BAAkD,GAEXV,EACrCU,GAGOC,IAEAJ,aAaKK,EACdF,0BAAkD,GAEXV,EACrCU,GA0cG9G,UAAUiH,cAAiBjH,UAAUiH,aAAaC,iBAOlDxH,EAAUS,YAKW,WAAtBgH,SAASC,SACJxH,QAAQE,OACb,IAAI1B,MAAM,gDAIPwB,QAAQyH,IAAI,CACjBT,IACA5G,UAAUiH,aAAaC,qBACtBhD,cAAMoD,4BACPC,EAAYhJ,iBAAQiJ,GAClBC,EAAwBD,EAAYP,KAG/BM,IAlBA3H,QAAQE,OAAO,IAAI1B,MAAM,wCAPzBwB,QAAQE,OACb,IAAI1B,MAAM,qDAvcLwI,aAcKc,EAAmBC,OAC7BC,EAAQzB,EAAewB,GAG3BtD,EAAQ,mBAAqBsD,EAAGrI,WAAY,CAAEqI,GAAIC,aAcpCC,EAAkBF,UAGzB1D,EAAwB,mBAAoB,CAAE0D,GAFzCxB,EAAewB,cAUbG,EAAaC,UAGpB9D,EAAwB,eAAgB,CAAE8D,KAFnC3B,EAAgB2B,KAQhC,SAAgBC,WACP/D,EAA+B,kBAOxC,SAASI,EACPR,EACAoE,EACAC,qBADsB,sBACa,MAGhCA,GACAA,GAA2BxI,EAAUS,mBAiBhC,IAAI/B,MAAM,2CAbZS,EAAM,CACR6C,UAAW,2CACXE,QAASiC,EACToE,KAAMA,GAAQ,GACdnH,WANerB,KAAiBH,WAOhCH,YAAaA,EACbiD,cAAelF,GAGjByB,EAAOC,MAAM,sCAAwCX,KAAKC,UAAUW,IAEpE4C,OAAO0G,YAAYtJ,EAAK,KAU5B,SAASoF,EACPJ,EACAoE,EACAC,qBADsB,sBACa,IAGhCA,GACAA,GAA2BxI,EAAUS,YACtC,KACIW,GAAarB,KAAiBH,kBAE3B,IAAIM,iBAAYC,EAASC,GAC9BN,EAAqBf,IAAIqC,EAAW,KAAE+C,UAAKhE,SAASC,QAEhDjB,EAAM,CACR6C,UAAW,2CACXE,QAASiC,EACToE,KAAMA,GAAQ,GACdnH,UAAWA,EACX3B,YAAaA,EACbiD,cAAelF,GAGjByB,EAAOC,MACL,uDACEX,KAAKC,UAAUW,IAGnB4C,OAAO0G,YAAYtJ,EAAK,cAGnBe,QAAQE,OAAO,IAAI1B,MAAM,iDAQpBgK,EACdC,EACAb,UAEKa,GAAiBb,EAM2B,mBAAnCa,EAAqBC,UAC1B1I,QAAQE,OACb,IAAI1B,MACF,oEAKEiK,EACLC,UAAUd,EAAWe,sBACrBrE,uBAEImE,EAAqBG,SAAWhB,EAAWe,uBAjBzC3I,QAAQE,OACb,IAAI1B,MAAM,gEAyBAqK,EACdC,EACAlB,OAEKkB,IAAgBlB,QACbpJ,MAAM,oEAGVuK,EAASD,EAAYE,iBAChBzF,EAAI,EAAG0F,EAAMF,EAAO3F,OAAQG,EAAI0F,EAAK1F,OAChCwF,EAAOxF,GACE2F,kBACRC,WAAavB,EAAWwB,2BAC5B,SAIJ,WAaOC,EACdC,OAGKlJ,UAAUiH,eAAiBjH,UAAUiH,aAAakC,oBAC9CvJ,QAAQE,OACb,IAAI1B,MAAM,yDAKTsB,EAAUS,mBACNP,QAAQE,OAAO,IAAI1B,MAAM,2CAIR,WAAtB+I,SAASC,UACXzI,EAAOM,KACL,yFAMFiK,MAAAA,GAEuB,iBAAhBA,SAEAtJ,QAAQE,OACb,IAAI1B,MAAM,8DAOLgL,EACPC,EACAC,MAEIA,MAAAA,GAA2D,iBAATD,EAAmB,KACnEhG,EAAmC,OAClC,IAAIkG,KAAYD,EACnBjG,EAAOkG,GAAaD,EAAeC,OAEhC,IAAIA,KAAYF,EACnBhG,EAAOkG,GAAYH,EAChBC,EAAaE,GACbD,EAAeC,WAGblG,SAEAgG,SAOJrJ,UAAUiH,aACdkC,aAAaC,EAAiB,CAAEI,OAAO,GAAQN,IAC/ChF,cAAKuF,UACG1C,IAA0C7C,cAAKsD,UAEpDiC,EAAYC,YAAYnL,iBAAQoL,GAC9BA,EAAMC,SAGJpC,GAAcA,EAAWwB,oBACpBhJ,UAAUiH,aACdkC,aACCC,EACE,CAAEI,MAAO,CAAET,SAAUvB,EAAWwB,sBAChCE,IAGHhF,cAAK2F,SACG,CACLA,OAAQA,EACRrC,WAAYA,KAIX5H,QAAQE,OACb,IAAI1B,MAAM,wDAUtB,SAASqJ,EACPD,EACAP,YA4ES6C,EACPC,EACAC,EACAC,UAEOA,EAAI5E,cAAK6E,UAAMA,EAAGH,SAAWA,GAAWG,EAAGF,MAAQA,OAGxDxC,GAAcA,EAAW2C,WAAY,KACnCJ,OAA8B1I,EAC9B+I,OAAmC/I,EACnCgJ,OAAoChJ,EACpCiJ,OAA4BjJ,EAE5BkJ,EAAoBtD,EAAahE,gBACnCuH,UACEA,EAAOF,OACPE,EAAOF,MAAMG,cAAcrN,SAAS,WACnB,eAAhBoN,EAAOR,MAAyC,gBAAhBQ,EAAOR,QAExCU,GA7FJC,EA8FEnD,EAAW2C,WAhD2B,IA7CxCS,EA8FEL,EAAkB1H,aAAIqH,UAAMA,EAAGI,SAjDHtH,OACrB,EACE4H,EAA0B5H,OAAS,EACzB4H,EAA0B/H,aAAIgI,MAC3CA,EAAUzN,SAAS,IAAMuN,EAAgB,YACpC,MAGHG,EAAYD,EAAUE,QAAQ,OAC9BC,EACFF,GAAa,EAAID,EAAU9I,UAAU+I,EAAY,GAAKD,kBAxBjCI,EAAYC,OACnCC,EAyB2BR,EAxB3BS,EAwB0CJ,EAAfL,EAvBxB3H,OAuBuCgI,EAvB3BhI,SACjBmI,EAsB4CH,EArB5CI,EAqB6BT,OAnB3BU,EAAeF,EAAOnI,cACL,IAAjBqI,EACK,GAEDA,WAtCYJ,EAAYC,GAChCD,EAAKA,EAAGR,cACRS,EAAKA,EAAGT,sBAEJa,EAAQ,IAAI1G,MACPzB,EAAI,EAAGA,GAAK8H,EAAGjI,OAAQG,IAAK,SAC/BoI,EAAYpI,EACPqI,EAAI,EAAGA,GAAKN,EAAGlI,OAAQwI,OACrB,GAALrI,EAAQmI,EAAME,GAAKA,UAEjBA,EAAI,EAAG,KACLC,EAAWH,EAAME,EAAI,GACrBP,EAAGS,OAAOvI,EAAI,IAAM+H,EAAGQ,OAAOF,EAAI,KACpCC,EACErM,KAAKuM,IAAIvM,KAAKuM,IAAIF,EAAUF,GAAYD,EAAME,IAAM,GACxDF,EAAME,EAAI,GAAKD,EACfA,EAAYE,EAIdtI,EAAI,IAAGmI,EAAMJ,EAAGlI,QAAUuI,UAEzBD,EAAMJ,EAAGlI,QAgBO4I,CAAaT,EAAQC,IAAYC,EAe7CQ,KAGuBC,gBAC/BC,EAAc7K,EAAOiC,EAAG8B,UACvB/D,EAAQ+D,EAAE8G,GAAgB5I,EAAI4I,GAChC,IAIM,MA6BNrB,GAAwB,EAAG,KACzBsB,EAAczB,EAAkBG,MACpCX,EAAUiC,EAAYjC,QACtBO,EAAQ0B,EAAY1B,MACK,eAArB0B,EAAYhC,KAAuB,CACrCI,EAAe4B,EAAYjD,aAEvBkD,EAAenC,EACjBC,EACA,cACAQ,GAEE0B,IACF5B,EAAgB4B,EAAalD,eAE1B,GAAyB,gBAArBiD,EAAYhC,KAAwB,CAC7CK,EAAgB2B,EAAYjD,aAExBmD,EAAcpC,EAChBC,EACA,aACAQ,GAEE2B,IACF9B,EAAe8B,EAAYnD,WAI7BgB,IACFvC,EAAW2E,eAAiBpC,GAE1BO,IACF9C,EAAW4E,aAAe9B,GAExBF,IACF5C,EAAWwB,oBAAsBoB,GAE/BC,IACF7C,EAAWe,qBAAuB8B,OAvIpCM,EACAC,EA6MJ,SAAS7D,WAEF/G,UAAUiH,cAAiBjH,UAAUiH,aAAaC,iBAOlDxH,EAAUS,YAKW,WAAtBgH,SAASC,SACJxH,QAAQE,OACb,IAAI1B,MAAM,gDAKPwB,QAAQyH,IAAI,CACjBV,IACA3G,UAAUiH,aAAaC,qBACtBhD,cAAMoD,qBACPG,EAAwBD,QACjBA,IAhBA5H,QAAQE,OAAO,IAAI1B,MAAM,wCAPzBwB,QAAQE,OACb,IAAI1B,MAAM,qDA6BhB,SAASgI,EAAgBI,MAEb,KAARA,IACgB,iBAARA,GAAqBA,aAAuBpC,cAErC,SAARoC,GAA0B,MAARA,EACpB,GAAmB,kBAARA,SACTA,QAED,IAAIpI,MAAM,yDAOpB,SAAS+H,EAAeK,MAEZ,KAARA,IACgB,iBAARA,GAAqBA,aAAuBpC,eAE7CpC,SAASwE,GACX,GAAkB,iBAAPA,SACTA,QAED,IAAIpI,MAAM,6ECzuDpB,IAAIqF,EAAM4I,OAAOC,UAAUC,eACvBC,EAAS,IASb,SAASC,KA4BT,SAASC,EAAGC,EAAIC,EAASC,GACvBC,KAAKH,GAAKA,EACVG,KAAKF,QAAUA,EACfE,KAAKD,KAAOA,IAAQ,EActB,SAASE,EAAYC,EAASxO,EAAOmO,EAAIC,EAASC,GAChD,GAAkB,mBAAPF,EACT,MAAM,IAAIM,UAAU,mCAGtB,IAAIC,EAAW,IAAIR,EAAGC,EAAIC,GAAWI,EAASH,GAC1CM,EAAMX,EAASA,EAAShO,EAAQA,EAMpC,OAJKwO,EAAQI,QAAQD,GACXH,EAAQI,QAAQD,GAAKR,GAC1BK,EAAQI,QAAQD,GAAO,CAACH,EAAQI,QAAQD,GAAMD,GADhBF,EAAQI,QAAQD,GAAK5H,KAAK2H,IADlCF,EAAQI,QAAQD,GAAOD,EAAUF,EAAQK,gBAI7DL,EAUT,SAASM,EAAWN,EAASG,GACI,KAAzBH,EAAQK,aAAoBL,EAAQI,QAAU,IAAIX,SAC5CO,EAAQI,QAAQD,GAU9B,SAASI,IACPT,KAAKM,QAAU,IAAIX,EACnBK,KAAKO,aAAe,EAxElBhB,OAAOmB,SACTf,EAAOH,UAAYD,OAAOmB,OAAO,OAM5B,IAAIf,GAASgB,YAAWjB,GAAS,IA2ExCe,EAAajB,UAAUoB,WAAa,WAClC,IACIC,EACAxP,EAFAyP,EAAQ,GAIZ,GAA0B,IAAtBd,KAAKO,aAAoB,OAAOO,EAEpC,IAAKzP,KAASwP,EAASb,KAAKM,QACtB3J,EAAIoK,KAAKF,EAAQxP,IAAOyP,EAAMrI,KAAKiH,EAASrO,EAAK2P,MAAM,GAAK3P,GAGlE,OAAIkO,OAAO0B,sBACFH,EAAM7I,OAAOsH,OAAO0B,sBAAsBJ,IAG5CC,GAUTL,EAAajB,UAAU0B,UAAY,SAAmBxP,GACpD,IACIyP,EAAWnB,KAAKM,QADVZ,EAASA,EAAShO,EAAQA,GAGpC,IAAKyP,EAAU,MAAO,GACtB,GAAIA,EAAStB,GAAI,MAAO,CAACsB,EAAStB,IAElC,IAAK,IAAIxJ,EAAI,EAAG+K,EAAID,EAASjL,OAAQmL,EAAK,IAAIvJ,MAAMsJ,GAAI/K,EAAI+K,EAAG/K,IAC7DgL,EAAGhL,GAAK8K,EAAS9K,GAAGwJ,GAGtB,OAAOwB,GAUTZ,EAAajB,UAAU8B,cAAgB,SAAuB5P,GAC5D,IACIwP,EAAYlB,KAAKM,QADXZ,EAASA,EAAShO,EAAQA,GAGpC,OAAKwP,EACDA,EAAUrB,GAAW,EAClBqB,EAAUhL,OAFM,GAYzBuK,EAAajB,UAAU+B,KAAO,SAAc7P,EAAO8P,EAAIC,EAAIC,EAAIC,EAAIC,GACjE,IAAIvB,EAAMX,EAASA,EAAShO,EAAQA,EAEpC,IAAKsO,KAAKM,QAAQD,GAAM,OAAO,EAE/B,IAEIlF,EACA9E,EAHA6K,EAAYlB,KAAKM,QAAQD,GACzBtE,EAAM8F,UAAU3L,OAIpB,GAAIgL,EAAUrB,GAAI,CAGhB,OAFIqB,EAAUnB,MAAMC,KAAK8B,eAAepQ,EAAOwP,EAAUrB,QAAItL,GAAW,GAEhEwH,GACN,KAAK,EAAG,OAAOmF,EAAUrB,GAAGkB,KAAKG,EAAUpB,UAAU,EACrD,KAAK,EAAG,OAAOoB,EAAUrB,GAAGkB,KAAKG,EAAUpB,QAAS0B,IAAK,EACzD,KAAK,EAAG,OAAON,EAAUrB,GAAGkB,KAAKG,EAAUpB,QAAS0B,EAAIC,IAAK,EAC7D,KAAK,EAAG,OAAOP,EAAUrB,GAAGkB,KAAKG,EAAUpB,QAAS0B,EAAIC,EAAIC,IAAK,EACjE,KAAK,EAAG,OAAOR,EAAUrB,GAAGkB,KAAKG,EAAUpB,QAAS0B,EAAIC,EAAIC,EAAIC,IAAK,EACrE,KAAK,EAAG,OAAOT,EAAUrB,GAAGkB,KAAKG,EAAUpB,QAAS0B,EAAIC,EAAIC,EAAIC,EAAIC,IAAK,EAG3E,IAAKvL,EAAI,EAAG8E,EAAO,IAAIrD,MAAMiE,EAAK,GAAI1F,EAAI0F,EAAK1F,IAC7C8E,EAAK9E,EAAI,GAAKwL,UAAUxL,GAG1B6K,EAAUrB,GAAG3H,MAAMgJ,EAAUpB,QAAS3E,OACjC,CACL,IACIuD,EADAxI,EAASgL,EAAUhL,OAGvB,IAAKG,EAAI,EAAGA,EAAIH,EAAQG,IAGtB,OAFI6K,EAAU7K,GAAG0J,MAAMC,KAAK8B,eAAepQ,EAAOwP,EAAU7K,GAAGwJ,QAAItL,GAAW,GAEtEwH,GACN,KAAK,EAAGmF,EAAU7K,GAAGwJ,GAAGkB,KAAKG,EAAU7K,GAAGyJ,SAAU,MACpD,KAAK,EAAGoB,EAAU7K,GAAGwJ,GAAGkB,KAAKG,EAAU7K,GAAGyJ,QAAS0B,GAAK,MACxD,KAAK,EAAGN,EAAU7K,GAAGwJ,GAAGkB,KAAKG,EAAU7K,GAAGyJ,QAAS0B,EAAIC,GAAK,MAC5D,KAAK,EAAGP,EAAU7K,GAAGwJ,GAAGkB,KAAKG,EAAU7K,GAAGyJ,QAAS0B,EAAIC,EAAIC,GAAK,MAChE,QACE,IAAKvG,EAAM,IAAKuD,EAAI,EAAGvD,EAAO,IAAIrD,MAAMiE,EAAK,GAAI2C,EAAI3C,EAAK2C,IACxDvD,EAAKuD,EAAI,GAAKmD,UAAUnD,GAG1BwC,EAAU7K,GAAGwJ,GAAG3H,MAAMgJ,EAAU7K,GAAGyJ,QAAS3E,IAKpD,OAAO,GAYTsF,EAAajB,UAAUuC,GAAK,SAAYrQ,EAAOmO,EAAIC,GACjD,OAAOG,EAAYD,KAAMtO,EAAOmO,EAAIC,GAAS,IAY/CW,EAAajB,UAAUO,KAAO,SAAcrO,EAAOmO,EAAIC,GACrD,OAAOG,EAAYD,KAAMtO,EAAOmO,EAAIC,GAAS,IAa/CW,EAAajB,UAAUsC,eAAiB,SAAwBpQ,EAAOmO,EAAIC,EAASC,GAClF,IAAIM,EAAMX,EAASA,EAAShO,EAAQA,EAEpC,IAAKsO,KAAKM,QAAQD,GAAM,OAAOL,KAC/B,IAAKH,EAEH,OADAW,EAAWR,KAAMK,GACVL,KAGT,IAAIkB,EAAYlB,KAAKM,QAAQD,GAE7B,GAAIa,EAAUrB,GAEVqB,EAAUrB,KAAOA,GACfE,IAAQmB,EAAUnB,MAClBD,GAAWoB,EAAUpB,UAAYA,GAEnCU,EAAWR,KAAMK,OAEd,CACL,IAAK,IAAIhK,EAAI,EAAGwK,EAAS,GAAI3K,EAASgL,EAAUhL,OAAQG,EAAIH,EAAQG,KAEhE6K,EAAU7K,GAAGwJ,KAAOA,GACnBE,IAASmB,EAAU7K,GAAG0J,MACtBD,GAAWoB,EAAU7K,GAAGyJ,UAAYA,IAErCe,EAAOpI,KAAKyI,EAAU7K,IAOtBwK,EAAO3K,OAAQ8J,KAAKM,QAAQD,GAAyB,IAAlBQ,EAAO3K,OAAe2K,EAAO,GAAKA,EACpEL,EAAWR,KAAMK,GAGxB,OAAOL,MAUTS,EAAajB,UAAUwC,mBAAqB,SAA4BtQ,GACtE,IAAI2O,EAUJ,OARI3O,EAEEsO,KAAKM,QADTD,EAAMX,EAASA,EAAShO,EAAQA,IACT8O,EAAWR,KAAMK,IAExCL,KAAKM,QAAU,IAAIX,EACnBK,KAAKO,aAAe,GAGfP,MAMTS,EAAajB,UAAUyC,IAAMxB,EAAajB,UAAUsC,eACpDrB,EAAajB,UAAUS,YAAcQ,EAAajB,UAAUuC,GAK5DtB,EAAayB,SAAWxC,EAKxBe,EAAaA,aAAeA,EAM1B0B,UAAiB1B,8BCxTb2B,EAKF,CACFC,mBAAoB,CAAEC,UAAW,WAAYC,UAAW,WACxDC,mBAAoB,CAAEF,UAAW,WAAYC,UAAW,uCAC3B,CAC3BD,UAAW,kBACXC,UAAW,sCAEgB,CAC3BD,UAAW,kBACXC,UAAW,qCAEe,CAC1BD,UAAW,iBACXC,UAAW,qCAEe,CAC1BD,UAAW,iBACXC,UAAW,sCAEgB,CAC3BD,UAAW,gBACXC,UAAW,iCAEU,CAAED,UAAW,SAAUC,UAAW,wBAC3C,CAAED,UAAW,OAAQC,UAAW,YAGnCE,EAKX1R,SAAYoI,EAAc/E,EAAYsO,QAC/BvJ,KAAOA,OACP/E,MAAQA,OACRsO,UAAYA,GAAaC,KAAKC,OCpD1BC,GAAb9R,uBAEqC,IAG5B+R,aAAAA,aAAIpR,OAELqR,EAAQ/C,KAAKa,OAAOzL,mBAAUC,UACzB3D,EAAMgR,UAAYrN,EAAEqN,mBAId,IAAXK,IAAcA,EAAQ/C,KAAKa,OAAO3K,aAIjC2K,OAASb,KACJa,OAAOG,MAAM,EAAG+B,WACxBrR,GACAsO,KAAQa,OAAOG,MAAM+B,IAIhBrR,GAUFsR,aAAAA,gBAAOV,MAERA,EAAW,KACRW,IAAI5M,EAAI2J,KAAKa,OAAO3K,OAAS,EAAGG,EAAI,EAAGA,IAAK,KACzC3E,EAAQsO,KAAKa,OAAOxK,MAEtB3E,EAAMyH,OAASmJ,EAAW,OAAO5Q,SAGhC,YAIFsO,KAAKa,OAAOb,KAAKa,OAAO3K,OAAS,IAAM,MAUzCgN,aAAAA,cAAK/M,OACN0K,EAASb,KAAKa,UAEd1K,EAAQ,yEAGNgN,IACFtC,EAASA,EAAOG,MAAM,EAAGhB,KAAKa,OAAO5C,QAAQkF,KAG3CC,IACFvC,EAASA,EAAOG,MAAMhB,KAAKa,OAAO5C,QAAQmF,MAGxCd,GAAae,OACNxC,EAAO1K,gBAAQqE,6BAClB8H,IAAcA,EAAUhS,kBACxB+S,GAAYA,EAASC,OAASZ,EAAYW,EAASC,OAEnDD,GAAYA,EAASE,KAAOb,EAAYW,EAASE,QAOrDC,MACOA,EAAQ,EAAI3C,EAAOG,MAAM,EAAGwC,GAAS3C,EAAOG,MAAMwC,WAIxD3C,GAGFtN,aAAAA,sBACAsN,OAAS,QC5FL4C,eAMX1S,iDALiB,IAAI8R,GAQnBa,EAAuB,kBAAWC,MAE3B3D,EAAK4D,YAAa5D,EAAK6D,cAGtBnS,WF2CyBA,MAC/B,OAAQA,EAAMR,YACRQ,EAAMR,KAAK4S,QACZ,mBACI,IAAIrB,EAAe,YAAY,EAAM/Q,EAAMR,KAAK6S,iBACpD,qBACI,IAAItB,EAAe,cAAc,EAAM/Q,EAAMR,KAAK6S,iBAI1DC,IAAMC,KAAkB7B,KACvB6B,KAAkBvS,EAAMR,KAAM,KAC1BgT,EAAc9B,EAAgB6B,GAChC7P,EAAQ1C,EAAMR,KAAK+S,UAEfC,EAAY3B,eACb,UACHnO,EAAgC,SAAxBA,EAAMuJ,wBAEX,SACHvJ,EAAQ+P,OAAO/P,UAMZ,IAAIqO,EACTyB,EAAY5B,UACZlO,EACA1C,EAAMR,KAAK6S,oBAKV,KE7EWK,CAAqBT,GAE/BjS,MACGmP,OAAOiC,IAAIpR,KACX6P,KAAK7P,EAAMyH,KAAMzH,uGAKrB4R,sBACAM,UAAYjB,KAAKC,WACjBiB,cAAWtP,eAGXuI,qBACA+G,SAAWlB,KAAKC,mBAGhBrP,sBACAsN,OAAOtN,qBAGP8Q,+BACCC,EAAWtE,KAAKa,OAAOmC,OAAO,YAC9BuB,EAAWvE,KAAKa,OAAOmC,OAAO,YAC9BwB,IAAeF,GAAWA,EAASlQ,MACnCqQ,IAAeF,GAAWA,EAASnQ,MACnCsQ,EAAiBF,GAAgBC,QAGhC,WAFWD,IAAiBC,iBAIjCC,EACAF,cAAcE,GAAyBF,EACvCC,cAAcC,GAAyBD,gBAIpCE,uBAAcC,EAAmBC,OAChCC,EAGF,CAAExC,UAAW,qBAEbsC,GAAYC,IACdC,EAAMzB,SAAW,CAAEC,MAAOsB,EAAUrB,IAAKsB,QAQvCE,EAGAC,EAGAC,EAXApE,EAASb,KAAKa,OAAOqC,KAAK4B,GACxBlB,EAAYgB,GAAY5E,KAAK4D,WAAa,EAC1CsB,EAAUL,GAAU7E,KAAK6D,UAAYlB,KAAKC,MAE5CuC,EAAa,EAGbC,EAAa,EAGbC,EAAoB,KAGpBT,GAAYC,EAAQ,KAChBS,EAA6BtF,KAAKa,OAAOqC,KAAK,CAClDZ,UAAW,WACXa,WAAYtC,EAAO,GACnB2C,OAAQ,IACP,GACG+B,EAA6BvF,KAAKa,OAAOqC,KAAK,CAClDZ,UAAW,WACXa,WAAYtC,EAAO,GACnB2C,OAAQ,IACP,GAMD8B,IACqC,IAArCA,EAA2BlR,OAE3ByM,EAAO2E,QAAQ,IAAI/C,EAAe,YAAY,EAAMmB,IAOpD2B,IACqC,IAArCA,EAA2BnR,OAE3ByM,EAAO2E,QAAQ,IAAI/C,EAAe,YAAY,EAAMmB,IAKtD/C,EAAOpI,KACL,IAAIgK,EAAe,YAAY,EAAOyC,GACtC,IAAIzC,EAAe,YAAY,EAAOyC,QAIrC,UAAarE,kBAAQ,CAArBoC,IAAIvR,OACD+T,EAA2B,aAAf/T,EAAMyH,KAClBuM,EAA2B,aAAfhU,EAAMyH,KAGpBsM,IAA6B,IAAhB/T,EAAM0C,QAAmB2Q,IACxCA,EAAerT,GAIbgU,IAA6B,IAAhBhU,EAAM0C,QAAmB4Q,IACxCA,EAAetT,GAIb+T,IAA6B,IAAhB/T,EAAM0C,OAAmB2Q,IAEpCE,GACFI,GAAqB3T,EAAMgR,UAAYuC,EAAoBvC,UAC3DuC,OAAsB1Q,EAGlByQ,IAAcA,EAAetT,IAIjCyT,GAAczT,EAAMgR,UAAYqC,EAAarC,UAG/CqC,OAAexQ,GAIbmR,IAA6B,IAAhBhU,EAAM0C,OAAmB4Q,IAEpCC,GACFI,GAAqB3T,EAAMgR,UAAYuC,EAAoBvC,UAC3DuC,OAAsB1Q,EAClBwQ,IAAcA,EAAerT,IAIjC0T,GAAc1T,EAAMgR,UAAYsC,EAAatC,UAG/CsC,OAAezQ,GAIbwQ,GAAgBC,IAAiBC,IAEnCA,EAAsBvT,EAGlB+T,IACFL,GAAc1T,EAAMgR,UAAYsC,EAAatC,WAI3CgD,IACFP,GAAczT,EAAMgR,UAAYqC,EAAarC,gBAK7CiD,EAAYT,EAAUtB,EACtBgC,EACJD,GAAaR,EAAaC,EAAaC,GAEnCQ,WAAuBC,WAGlBxT,KAAKyT,MAFD,IAAMD,EAAYH,EAEL,OAAS,cAG9B,WACLA,EACAK,aAAcb,EACdc,gBAAiBJ,EAAoBV,GACrCe,aAAcd,EACde,gBAAiBN,EAAoBT,GACrCgB,cAAef,EACfgB,iBAAkBR,EAAoBR,GACtCO,YAAaA,EACbU,eAAgBT,EAAoBD,iBAIxCW,8BACQ7U,EAAQsO,KAAKa,OAAOmC,OAAO,gBAC1BtR,GAAQA,EAAM0C,mBAEvBoS,gCACSxG,KAAKa,OAAOqC,KAAK,CAAEZ,UAAW,SAAUnM,gBAAOzE,UAASA,EAAM0C,QAClE8B,oBAGLuQ,gCACQ/U,EAAQsO,KAAKa,OAAOmC,OAAO,kBAC1BtR,EAAQA,EAAM0C,WAAQG,eAE/BmS,4CACS1G,KAAKa,OACTqC,KAAK,CAAEZ,UAAW,YAClBnM,gBAAOzE,UAASA,EAAM0C,QAAO8B,oBAGlCyQ,mCACS3G,KAAKa,OACTqC,KAAK,CAAEZ,UAAW,aAClBnM,gBAAOzE,UAASA,EAAM0C,QAAO8B,oBAElC0Q,qCACS5G,KAAKa,OACTqC,KAAK,CAAEZ,UAAW,eAClBnM,gBAAOzE,UAASA,EAAM0C,QAAO8B,oBAGlC2Q,0BAAiBrD,0BAAiB,IACzBxD,KAAKa,OAAOqC,KAAK,OAAEM,EAAOlB,UAAW,iCAE9CwE,iCAAwBlC,EAAmBC,OAGrChE,EAA2B,MAE3B+D,GAAYC,EAAQ,KAChBkC,EAAuB/G,KAAKa,OAAOqC,KAAK,WAL9B,kBAOdG,SAAU,CAAEC,MAAOsB,EAAUrB,IAAKsB,KAQpChE,EANiCb,KAAKa,OAAOqC,KAAK,WATlC,kBAWdC,WAAY4D,EAAqB,GACjCvD,OAAQ,WAGgCuD,QAE1ClG,EAASb,KAAKa,OAAOqC,KAAK,WAjBV,uBAuBI,IAAlBrC,EAAO3K,OAAc,OAAO,KAEV,IAAlB2K,EAAO3K,OAAc,OAAO2K,EAAO,GAAGzM,cAEtC4S,EAAM,EACNC,EAAc,EAGT5Q,EAAI,EAAGA,EAAIwK,EAAO3K,OAAS,EAAGG,IAAK,KACpC6Q,EAASrG,EAAOxK,GAGhB8Q,EAFStG,EAAOxK,EAAI,GAEJqM,UAAYwE,EAAOxE,UAEzCsE,GAAOG,EAASD,EAAO9S,MACvB6S,GAAeE,SAIV7U,KAAKyT,MAAMiB,EAAMC,gBAG1BG,4BAAmB5D,0BAAiB,IAC3BxD,KAAKa,OAAOqC,KAAK,OAAEM,EAAOlB,UAAW,iCAE9C+E,mCAA0BzC,EAAmBC,OAGvChE,EAA2B,MAE3B+D,GAAYC,EAAQ,KAChBkC,EAAuB/G,KAAKa,OAAOqC,KAAK,WAL9B,kBAOdG,SAAU,CAAEC,MAAOsB,EAAUrB,IAAKsB,KAQpChE,EANiCb,KAAKa,OAAOqC,KAAK,WATlC,kBAWdC,WAAY4D,EAAqB,GACjCvD,OAAQ,WAGgCuD,QAE1ClG,EAASb,KAAKa,OAAOqC,KAAK,WAjBV,uBAuBI,IAAlBrC,EAAO3K,OAAc,OAAO,KAEV,IAAlB2K,EAAO3K,OAAc,OAAO2K,EAAO,GAAGzM,cAEtC4S,EAAM,EACNC,EAAc,EAGT5Q,EAAI,EAAGA,EAAIwK,EAAO3K,OAAS,EAAGG,IAAK,KACpC6Q,EAASrG,EAAOxK,GAGhB8Q,EAFStG,EAAOxK,EAAI,GAEJqM,UAAYwE,EAAOxE,UAEzCsE,GAAOG,EAASD,EAAO9S,MACvB6S,GAAeE,SAIV7U,KAAKyT,MAAMiB,EAAMC,OAxUGxG"}